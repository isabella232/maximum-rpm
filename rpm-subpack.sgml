<chapter id="ch-rpm-subpack">
<title>Creating Subpackages</title>
<!-- label: rpm-subpack -->

<indexterm>
<primary>subpackages</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

In this chapter, we will explore one of RPM's more interesting
capabilities: the capability to create subpackages.

<sect1 id="s1-rpm-subpack-">
<title>What Are Subpackages?</title>
<indexterm>
<primary>subpackages!definition of</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Very simply put, a subpackage is one of several package files created from
a single spec file.  RPM has the ability to create a main package, along
with one or more subpackages.  Subpackages may also be created without the
main package.  It's all up to the package builder.

<indexterm>
<primary>subpackages!definition of|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect1>

<sect1 id="s1-rpm-subpack-">
<title>Why Are They Needed?</title>
<indexterm>
<primary>subpackages!why needed</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

If all the software in the world followed the usual "one source, one
binary" structure, there would be no need for subpackages.  After all, RPM
handles the building and packaging of a program into a single package file
just fine.

But software doesn't always conform to this simplistic structure.  It's not
unusual for software to support two or more different modes of operation.
A client/server program, for example, comes in two flavors: a client, and a
server.

And it can get more complicated than that.  Sometimes software relies on
another program so completely that the two cannot be built separately.
The result is often several packages.

While it is certainly possible that some convoluted procedure could be
devised to force these kinds of software into a single-package structure,
it makes more sense to let RPM manage the creation of subpackages.  Why?
From the package builder's viewpoint, the main reason to use subpackages is
to eliminate any duplication of effort.

By using subpackages, there's no need to maintain separate spec files and
endure the resulting headaches when new versions of the software become
available.  By keeping everything in one spec file, new software versions
can be quickly integrated, and every related subpackage rebuilt with a
single command.

But that's enough of the preliminaries.  Let's see how subpackages are
created.

<indexterm>
<primary>subpackages!why needed|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect1>

<sect1 id="s1-rpm-subpack-">
<title>Our Example Spec File: Subpackages Galore!</title>
<indexterm>
<primary>subpackages!example requirements</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Throughout this chapter, we'll be constructing a spec file that will
consist of a number of subpackages.  Let's start by listing the spec file's
requirements:

<itemizedlist mark="bullet">
<listitem>
<para>
The main package name is to be <tt?>foo</tt?>.

</para>
</listitem>

<listitem>
<para>
The version is to be 2.7.

</para>
</listitem>

<listitem>
<para>
There are three subpackages:

<itemizedlist mark="bullet">
<listitem>
<para>
The server subpackage, to be called <tt?>foo-server</tt?>.

</para>
</listitem>

<listitem>
<para>
The client subpackage, to be called <tt?>foo-client</tt?>.

</para>
</listitem>

<listitem>
<para>
The <tt?>baz</tt?> development library subpackage, to be called
<tt?>bazlib</tt?>.

</para>
</listitem>

</itemizedlist>
</para>
</listitem>

<listitem>
<para>
The <tt?>bazlib</tt?> subpackage has a version of 5.6.

</para>
</listitem>

<listitem>
<para>
Each subpackage will have its own <tt?>summary</tt?> and
<tt?>description</tt?> tags.

</para>
</listitem>

</itemizedlist>
Every spec file starts with a preamble, and this one is no different.  In
this case, the preamble will contain the following tags:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...
</screen>
</figure>
As we can see, there's nothing different here: this is an ordinary spec
file so far.  Let's delve into things a bit more and see what we'll need
to add to this spec file to create the subpackages we require.

<indexterm>
<primary>subpackages!example requirements|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect1>

<sect1 id="s1-rpm-subpack-">
<title>Spec File Changes For Subpackages</title>
<indexterm>
<primary>subpackages!spec file changes</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The creation of subpackages is based strictly on the contents of the spec
file.  This doesn't mean that you'll have to learn an entirely new set of
tags, conditionals, and directives in order to create subpackages.  In
fact, you'll only need to learn one.

The primary change to a spec file is structural and starts with the
definition of a preamble for each subpackage.

<sect2 id="s2-rpm-subpack-">
<title>The Subpackage's "Preamble"</title>
When we introduced RPM package building in chapter <xref linkend="rpm-basics">, we
said that every spec file contains a preamble.  The preamble contains a
variety of tags that define all sorts of information about the package.  In
a single package situation, the preamble must be at the start of the spec
file.  The spec file we're creating will have one there, too.

When creating a spec file that will build subpackages, each subpackage also
needs a preamble of its own.  These "sub-preambles" need only define
information for the subpackage when that information differs from what is
defined in the main preamble.  For example, if we wanted to define an
installation prefix for a subpackage, we would add the appropriate
<tt?>prefix</tt?> tag to that subpackage's preamble.

<indexterm>
<primary>prefix@<tt?>prefix</tt?> tag</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

  That subpackage would
then be relocatable.

In a single-package spec file, there is nothing that explicitly identifies
the preamble, other than its position at the top of the file.  For
subpackages, however, we need to be a bit more explicit.  So we use the
<tt?>%package</tt?> directive to identify the preamble for each subpackage.

<sect3 id="s3-rpm-subpack-">
<title>The <tt?>\%package</tt?> Directive</title>
<indexterm>
<primary>subpackages!<tt?>%package</tt?> directive</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>package@<tt?>%package</tt?> directive</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <tt?>%package</tt?> directive actually performs two functions.  As we
mentioned above, it is used to denote the start of a subpackage's
preamble.  It also plays a role in forming the subpackage's name.  As an
example, let's say the main preamble contains the following <tt?>name</tt?>
tag:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
name: foo
</screen>
</figure>
Later in the spec file, there is a <tt?>%package</tt?> directive:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package bar
</screen>
</figure>
This would result in the name of the subpackage being <tt?>foo-bar</tt?>.

In this way, it's easy to see the relationship of the subpackage to the
main package (or other subpackages, for that matter).  Of course, this
naming convention might not be appropriate in every case.  So there is an
option to the <tt?>%package</tt?> directive for just this circumstance.

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>Adding <tt?>-n</tt?> To the <tt?>\%package</tt?> directive</title>
<indexterm>
<primary>subpackages!<tt?>%package</tt?> directive!<tt?>-n</tt?> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>package@<tt?>%package</tt?> directive!<tt?>-n</tt?> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <tt?>-n</tt?> option is used to change the final name of a subpackage
from <tt?>mainpackage-subpackage</tt?> to <tt?>subpackage</tt?>.  Let's modify
the <tt?>%package</tt?> directive in our example above to be:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package -n bar
</screen>
</figure>
The result is that the subpackage name would then be <tt?>bar</tt?> instead
of <tt?>foo-bar</tt?>.

<indexterm>
<primary>subpackages!<tt?>%package</tt?> directive!<tt?>-n</tt?> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>package@<tt?>%package</tt?> directive!<tt?>-n</tt?> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>subpackages!<tt?>%package</tt?> directive|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>package@<tt?>%package</tt?> directive|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>Updating Our Spec File</title>
Let's apply some of our newly found knowledge to the spec file we're
writing.  Here's the list of subpackages that we need to create:

<itemizedlist mark="bullet">
<listitem>
<para>
The server subpackage, to be called <tt?>foo-server</tt?>.

</para>
</listitem>

<listitem>
<para>
The client subpackage, to be called <tt?>foo-client</tt?>.

</para>
</listitem>

<listitem>
<para>
The <tt?>baz</tt?> development library subpackage, to be called
<tt?>bazlib</tt?>.

</para>
</listitem>

</itemizedlist>
Since our package name is <tt?>foo</tt?>, and since the <tt?>%package</tt?>
directive creates subpackage names by prepending the package name, the
<tt?>%package</tt?> directives for the <tt?>foo-server</tt?> and
<tt?>foo-client</tt?> subpackages would be written as:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package server
</screen>
</figure>
and

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package client
</screen>
</figure>
Since the <tt?>baz</tt?> library's package name is <emphasis>not</emphasis> to start with
<tt?>foo</tt?>, we need to use the <tt?>-n</tt?> option on its
<tt?>%package</tt?> directive:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package -n bazlib
</screen>
</figure>
Our requirements further state that <tt?>foo-server</tt?> and
<tt?>foo-client</tt?> are to have the same version as the main package.

One of the time-saving aspects of using subpackages is that
there is no need to duplicate information for each subpackage if it is
already defined in the main package.  Therefore, since the main package's
preamble has a <tt?>version</tt?> tag defining the version as 2.7, the two
subpackages that lack a <tt?>version</tt?> tag in their preambles will simply
inherit the main package's version definition.

Since the <tt?>bazlib</tt?> subpackage's preamble contains a <tt?>version</tt?>
tag, it must have its own unique version.

In addition, each subpackage must have its own <tt?>summary</tt?> tag.

So based on these requirements, our spec file now looks like this:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...

%package server
Summary: The foo server

%package client
Summary: The foo client

%package -n bazlib
Version: 5.6
Summary: The baz library
</screen>
</figure>
We can see the subpackage structure starting to appear now.

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>Required Tags In Subpackages</title>
<indexterm>
<primary>subpackages!tags required by</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

There are a few more tags we should add to the subpackages in our example
spec file.  In fact, if these tags are <emphasis>not</emphasis> present, RPM will issue a
most impressive warning:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba foo-2.7.spec</userinput>
* Package: foo
* Package: foo-server
Field must be present    : Description
Field must be present    : Group
* Package: foo-client
Field must be present    : Description
Field must be present    : Group
* Package: bazlib
Field must be present    : Description
Field must be present    : Group

Spec file check failed!!
Tell rpm-list@redhat.com if this is incorrect.
#
</screen>
</figure>
Our spec file is incomplete.  The bottom line is that each subpackage
<emphasis>must</emphasis> have these three tags:

<orderedlist>
<listitem>
<para>
The <tt?>%description</tt?> tag.

</para>
</listitem>

<listitem>
<para>
The <tt?>group</tt?> tag.

</para>
</listitem>

<listitem>
<para>
The <tt?>summary</tt?> tag.

</para>
</listitem>

</orderedlist>
It's easy to see that the first two tags are required, but what about
<tt?>summary</tt?>?  Well, we lucked out on that one: we already included a
<tt?>summary</tt?> for each subpackage in our example spec file.

Let's take a look at the <tt?>%description</tt?> tag first.

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>The <tt?>\%description</tt?> Tag</title>
As you've probably noticed, the <tt?>%description</tt?> tag differs from
other tags.  First of all, it starts with a percent sign.  Secondly, its
data can span multiple lines.  The third difference is that the
<tt?>%description</tt?> tag must include the name of the subpackage it
describes.  This is done by appending the subpackage name to the
<tt?>%description</tt?> tag itself.  So given these <tt?>%package</tt?>
directives:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package server
%package client
%package -n bazlib
</screen>
</figure>
our <tt?>%description</tt?> tags would start with:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%description server
%description client
%description -n bazlib
</screen>
</figure>
Notice that we've included the <tt?>-n</tt?> option in the
<tt?>%description</tt?> tag for <tt?>bazlib</tt?>.  This was intentional, as
it makes the name completely unambiguous.

<indexterm>
<primary>subpackages!tags required by|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>Our Spec File So Far&hellip;</title>
OK, let's take a look at the spec file after we've added the appropriate
<tt?>%description</tt?>s, along with <tt?>group</tt?> tags for each
subpackage:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...

%package server
Summary: The foo server
Group: bogus/junque
%description server
This is the long description for the foo server...

%package client
Summary: The foo client
Group: bogus/junque
%description client
This is the long description for the foo client...

%package -n bazlib
Version: 5.6
Summary: The baz library
Group: bogus/junque
%description -n bazlib
This is the long description for the bazlib...
</screen>
</figure>
Let's take a look at what we've done.  We've created a main preamble as we
normally would.  We then created three additional preambles, each starting
with a <tt?>%package</tt?> directive.  Finally, we added a few tags to the
subpackage preambles.

But what about <tt?>version</tt?> tags?  Aren't the <tt?>server</tt?> and
<tt?>client</tt?> subpackages missing them?

Not really.  Remember that if a subpackage is missing a given tag, it will
inherit the value of that tag from the main preamble.  We're well on our
way to having a complete spec file, but we aren't quite there yet.

Let's continue by looking at the next part of the spec file that changes
when building subpackages.

</sect3>

</sect2>

<sect2 id="s2-rpm-subpack-">
<title>The <tt?>\%files</tt?> List</title>
<indexterm>
<primary>subpackages!<tt?>%files</tt?> list changes</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

In an ordinary single-package spec file, the <tt?>%files</tt?> list is used
to determine which files are actually going to be packaged.  It is no
different when building subpackages.  What <emphasis>is</emphasis> different, is that
there must be a <tt?>%files</tt?> list for each subpackage.

Since each <tt?>%files</tt?> list must be associated with a particular
<tt?>%package</tt?> directive, we simply label each <tt?>%files</tt?> list
with the name of the subpackage, as  specified by each <tt?>%package</tt?>
directive. Going back to our example, our <tt?>%package</tt?> lines were:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%package server
%package client
%package -n bazlib
</screen>
</figure>
Therefore, our <tt?>%files</tt?> lists should start with:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%files server
%files client
%files -n bazlib
</screen>
</figure>
In addition, we need the main package's <tt?>%files</tt?> list, which
remains unnamed:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%files
</screen>
</figure>
The contents of each <tt?>%files</tt?> list is dictated entirely by the
software's requirements.  If, for example, a certain file needs to be
packaged in more than one package, it's perfectly all right to include the
filename in more than one list.

<sect3 id="s3-rpm-subpack-">
<title>Controlling Packages With the <tt?>\%files</tt?> List</title>
The <tt?>%files</tt?> list wields considerable power over subpackages.  It's
even possible to prevent a package from being created by using the
<tt?>%files</tt?> list.  But is there a reason why you'd want to go to the
trouble of setting up subpackages, only to keep one from being created?

Actually, there is.  Take, for example, the case where client/server-based
software is to be packaged.  Certainly, it makes sense to create two
subpackages: one for the client and one for the server.  But what about the
main package?  Is there any need for it?

Quite often there's no need for a main package.  In those cases, removing
the main <tt?>%files</tt?> list entirely will result in no main package
being built.

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>A Point Worth Noting</title>
Please keep in mind that an empty <tt?>%files</tt?> list (ie, a
<tt?>%files</tt?> list that contains no files) is <emphasis>not</emphasis> the same as not
having a <tt?>%files</tt?> list at all.  As we noted above, entirely
removing a <tt?>%files</tt?> list results in RPM not creating that package.
However, if RPM comes across a <tt?>%files</tt?> list with no files, it will
happily create an empty package file.

This feature (which also works with subpackage <tt?>%files</tt?> lists)
comes in handy when used in concert with conditionals.  If a
<tt?>%files</tt?> list is enclosed by a conditional, the package will be
created (or not) based on the evaluation of the conditional.

<indexterm>
<primary>subpackages!<tt?>%files</tt?> list changes|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect3>

<sect3 id="s3-rpm-subpack-">
<title>Our Spec File So Far&hellip;</title>
Ok, let's update our example spec file.  Here's what it looks like after
adding each of the subpackages' <tt?>%files</tt?> lists:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...

%package server
Summary: The foo server
Group: bogus/junque

%package client
Summary: The foo client
Group: bogus/junque

%package -n bazlib
Version: 5.6
Summary: The baz library
Group: bogus/junque


%files
/usr/local/foo-file

%files server
/usr/local/server-file

%files client
/usr/local/client-file

%files -n bazlib
/usr/local/bazlib-file
</screen>
</figure>
As you can see we've added <tt?>%files</tt?> lists for:

<itemizedlist mark="bullet">
<listitem>
<para>
The main <tt?>foo</tt?> package.

</para>
</listitem>

<listitem>
<para>
The <tt?>foo-server</tt?> subpackage.

</para>
</listitem>

<listitem>
<para>
The <tt?>foo-client</tt?> subpackage.

</para>
</listitem>

<listitem>
<para>
The <tt?>bazlib</tt?> subpackage.

</para>
</listitem>

</itemizedlist>
Each package contains a single file.
<footnote>
<para>
Hey, we said it was a simple
example!
</para>
</footnote>
  If there was no need for a main package, we could simply remove
the unnamed <tt?>%files</tt?> list.  Keep in mind that even if you do not
create a main package, the tags defined in the main package's preamble
<emphasis>will</emphasis> appear somewhere -- specifically, in the source package file.

Let's look at the last subpackage-specific part of the spec file: the
install- and erase-time scripts.

</sect3>

</sect2>

<sect2 id="s2-rpm-subpack-">
<title>Install- and Erase-time Scripts</title>
<indexterm>
<primary>subpackages!script changes</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The install- and erase-time scripts, <tt?>%pre</tt?>, <tt?>%preun</tt?>,
<tt?>%post</tt?>, and <tt?>%postun</tt?>, can all be named using exactly the
same method as was used for the other subpackage-specific sections of the
spec file.  The script used during package verification,
<tt?>%verifyscript</tt?>, can be made package-specific as well.  Using the
subpackage structure from our example spec file, we would end up with
script definitions like:

<itemizedlist mark="bullet">
<listitem>
<para>
<tt?>%pre server</tt?>

</para>
</listitem>

<listitem>
<para>
<tt?>%postun client</tt?>

</para>
</listitem>

<listitem>
<para>
<tt?>%preun -n bazlib</tt?>

</para>
</listitem>

<listitem>
<para>
<tt?>%verifyscript client</tt?>

</para>
</listitem>

</itemizedlist>
Other than the change in naming, there's only one thing to be aware of when
creating scripts for subpackages.  It's important that you consider the
possibility of scripts from various subpackages interacting with each
other.  Of course, this is simply good script-writing practice, even if the
packages involved are not related.

<indexterm>
<primary>subpackages!script changes|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<sect3 id="s3-rpm-subpack-">
<title>Back At the Spec File&hellip;</title>
Here we've added some scripts to our spec file.  So that our example
doesn't get too complex, we've just added preinstall scripts for each
package:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...

%package server
Summary: The foo server
Group: bogus/junque
%description server
This is the long description for the foo server...

%package client
Summary: The foo client
Group: bogus/junque
%description client
This is the long description for the foo client...

%package -n bazlib
Version: 5.6
Summary: The baz library
Group: bogus/junque
%description -n bazlib
This is the long description for the bazlib...


%pre
echo "This is the foo package preinstall script"

%pre server
echo "This is the foo-server subpackage preinstall script"

%pre client
echo "This is the foo-client subpackage preinstall script"

%pre -n bazlib
echo "This is the bazlib subpackage preinstall script"

%files
/usr/local/foo-file

%files server
/usr/local/server-file

%files client
/usr/local/client-file

%files -n bazlib
/usr/local/bazlib-file
</screen>
</figure>
As pre-install scripts go, these don't do very much.  But they will allow
us to see how subpackage-specific scripts can be defined.

Those of you that have built packages before probably realize that our spec
file is missing something.  Let's add that part now.

</sect3>

</sect2>

</sect1>

<sect1 id="s1-rpm-subpack-">
<title>Build-Time Scripts: Unchanged For Subpackages</title>
<indexterm>
<primary>subpackages!build-time scripts, unchanged</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

While creating subpackages changes the general structure of the spec file,
there's one section that doesn't change: the build-time scripts.  This
means there is only one set of <tt?>%prep</tt?>, <tt?>%build</tt?>, and
<tt?>%install</tt?> scripts in any spec file.

Of course, even if RPM doesn't require any changes to these scripts, you
still might need to make some subpackage-related changes to them.  Normally
these changes are related to doing whatever is required to get the all the
software unpacked, built, and installed.  For example, if packaging
client/server software, the software for both the client <emphasis>and</emphasis> the
server must be unpacked, and then both the client <emphasis>and</emphasis> server
binaries must be built and installed.

<indexterm>
<primary>subpackages!build-time scripts, unchanged|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<sect2 id="s2-rpm-subpack-">
<title>Our Spec File: One Last Look&hellip;</title>
Let's add some build-time scripts and take a final look at the spec file:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
Name: foo
Version: 2.7
Release: 1
Source: foo-2.7.tgz
CopyRight: probably not
Summary: The foo app, and the baz library needed to build it
Group: bogus/junque
%description
This is the long description of the foo app, and the baz library needed to
build it...

%package server
Summary: The foo server
Group: bogus/junque
%description server
This is the long description for the foo server...

%package client
Summary: The foo client
Group: bogus/junque
%description client
This is the long description for the foo client...

%package -n bazlib
Version: 5.6
Summary: The baz library
Group: bogus/junque
%description -n bazlib
This is the long description for the bazlib...

%prep
%setup

%build
make

%install
make install

%pre
echo "This is the foo package preinstall script"

%pre server
echo "This is the foo-server subpackage preinstall script"

#%pre client
#echo "This is the foo-client subpackage preinstall script"

%pre -n bazlib
echo "This is the bazlib subpackage preinstall script"

%files
/usr/local/foo-file

%files server
/usr/local/server-file

%files client
/usr/local/client-file

%files -n bazlib
/usr/local/bazlib-file
</screen>
</figure>
As you can see, the build-time scripts are about as simple as they can
be.
<footnote>
<para>
This is the advantage to making up an example.  A more
real-world spec file would undoubtedly have more interesting scripts.
</para>
</footnote>

<indexterm>
<primary>subpackages!spec file changes|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

</sect1>

<sect1 id="s1-rpm-subpack-">
<title>Building Subpackages</title>
<indexterm>
<primary>subpackages!building</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Now it's time to give our example spec file a try.  The build process is
not that much different from a single-package spec file:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba foo-2.7.spec</userinput>
* Package: foo
* Package: foo-server
* Package: foo-client
* Package: bazlib
&hellip;
Executing: %prep
&hellip;
Executing: %build
&hellip;
Executing: %install
&hellip;
Executing: special doc
+ cd /usr/src/redhat/BUILD
+ cd foo-2.7
+ DOCDIR=//usr/doc/foo-2.7-1
+ DOCDIR=//usr/doc/foo-server-2.7-1
+ DOCDIR=//usr/doc/foo-client-2.7-1
+ DOCDIR=//usr/doc/bazlib-5.6-1
+ exit 0
Binary Packaging: foo-2.7-1
Finding dependencies...
usr/local/foo-file
1 block
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/foo-2.7-1.i386.rpm
Binary Packaging: foo-server-2.7-1
Finding dependencies...
usr/local/server-file
1 block
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/foo-server-2.7-1.i386.rpm
Binary Packaging: foo-client-2.7-1
Finding dependencies...
usr/local/client-file
1 block
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/foo-client-2.7-1.i386.rpm
Binary Packaging: bazlib-5.6-1
Finding dependencies...
usr/local/bazlib-file
1 block
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/bazlib-5.6-1.i386.rpm
&hellip;
Source Packaging: foo-2.7-1
foo-2.7.spec
foo-2.7.tgz
4 blocks
Generating signature: 0
Wrote: /usr/src/redhat/SRPMS/foo-2.7-1.src.rpm
#
</screen>
</figure>
Starting at the top, we start the build with the usual command.
Immediately following the command, RPM indicates that four packages are to
be built from this spec file.  The <tt?>%prep</tt?>, <tt?>%build</tt?>, and
<tt?>%install</tt?> scripts then execute as usual.

Next, RPM executes its "special doc" internal script, even though we
haven't declared any files to be documentation.  It's worth noting,
however, that the <tt?>DOCDIR</tt?> environment variables show that if the
spec file <emphasis>had</emphasis> declared some of the files as documentation, RPM would
have created the appropriate documentation directories for each of the
packages.

At this point, RPM creates the binary packages.  As we can see, each
package contains the file defined in its <tt?>%files</tt?> list.

Finally, the source package file is created.  It contains the spec file and
the original sources, just like any other source package.

One spec file.  One set of sources.  One build command.  Four
packages.
<footnote>
<para>
Five, if you count the source package.
</para>
</footnote>
  All in all, a
pretty good deal, isn't it?

<indexterm>
<primary>subpackages!building|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<sect2 id="s2-rpm-subpack-">
<title>Giving Subpackages the Once-Over</title>
<indexterm>
<primary>subpackages!testing</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Let's take a look at our newly created packages.  As with any other
package, each subpackage should be tested by installing it on a system that
has not had that software installed before.  In this section, we'll just
snoop around the subpackages and point out how they differ from packages
built one to a spec file.

First, let's just look at each package's information:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -qip foo-2.7-1.i386.rpm</userinput>
Name        : foo                   Distribution: (none)
Version     : 2.7                         Vendor: (none)
Release     : 1                       Build Date: Wed Nov 06 13:33:37 1996
Install date: (none)                  Build Host: foonly.rpm.org
Group       : bogus/junque            Source RPM: foo-2.7-1.src.rpm
Size        : 35
Summary     : The foo app, and the baz library needed to build it
Description :
This is the long description of the foo app, and the baz library needed to
build it...
#
# <userinput>rpm -qip foo-server-2.7-1.i386.rpm</userinput>
Name        : foo-server            Distribution: (none)
Version     : 2.7                         Vendor: (none)
Release     : 1                       Build Date: Wed Nov 06 13:33:37 1996
Install date: (none)                  Build Host: foonly.rpm.org
Group       : bogus/junque            Source RPM: foo-2.7-1.src.rpm
Size        : 42
Summary     : The foo server
Description :
This is the long description for the foo server...
#
# <userinput>rpm -qip foo-client-2.7-1.i386.rpm</userinput>
Name        : foo-client            Distribution: (none)
Version     : 2.7                         Vendor: (none)
Release     : 1                       Build Date: Wed Nov 06 13:33:37 1996
Install date: (none)                  Build Host: foonly.rpm.org
Group       : bogus/junque            Source RPM: foo-2.7-1.src.rpm
Size        : 42
Summary     : The foo client
Description :
This is the long description for the foo client...
#
# <userinput>rpm -qip bazlib-5.6-1.i386.rpm</userinput>
Name        : bazlib                Distribution: (none)
Version     : 5.6                         Vendor: (none)
Release     : 1                       Build Date: Wed Nov 06 13:33:37 1996
Install date: (none)                  Build Host: foonly.rpm.org
Group       : bogus/junque            Source RPM: foo-2.7-1.src.rpm
Size        : 38
Summary     : The baz library
Description :
This is the long description for the bazlib...
#
</screen>
</figure>
Here we've used RPM's query capability to display a list of summary
information for each package.  A few points are worth noting.

First, each package lists <tt?>foo-2.7-1.src.rpm</tt?> as its source package
file.  This is the only way to tell if two package files were created from
the same set of sources.  Trying to use a package's name as an indicator is
futile, as the <tt?>bazlib</tt?> package shows us.

The next thing to notice is that the summaries and descriptions for each
package are specific to that package.  Since these tags were placed and
named according to each package, that should be no surprise.

Finally, we can see that each package's version has been either
"inherited" from the main package's preamble, or, as in the case of the
<tt?>bazlib</tt?> package, the main package's version has been overridden by
a <tt?>version</tt?> tag added to <tt?>bazlib</tt?>'s preamble.

If we look at the source package's information, we see that its information
has been taken entirely from the main package's set of tags:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -qip foo-2.7-1.src.rpm</userinput>
Name        : foo                   Distribution: (none)
Version     : 2.7                         Vendor: (none)
Release     : 1                       Build Date: Wed Nov 06 13:33:37 1996
Install date: (none)                  Build Host: foonly.rpm.org
Group       : bogus/junque            Source RPM: (none)
Size        : 1415
Summary     : The foo app, and the baz library needed to build it
Description :
This is the long description of the foo app, and the baz library needed to
build it...
# 
</screen>
</figure>
It's easy to see that if there was no <tt?>%files</tt?> list for the main
package, and therefore, no main package, the tags in the main preamble
would still be used in the source package.  This is why RPM enforces the
requirement that the main preamble contain <tt?>copyright</tt?>,
<tt?>%description</tt?>, and <tt?>group</tt?> tags.  So, here's a word to the
wise: Don't put something stupid in the main preamble's
<tt?>%description</tt?> just to satisfy RPM.  Your witty saying will be
immortalized for all time in every source package you
distribute.
<footnote>
<para>
Yes, the author found out about this hard way!
</para>
</footnote>

<sect3 id="s3-rpm-subpack-">
<title>Verifying Subpackage-specific Install and Erase Scripts</title>
<indexterm>
<primary>subpackages!scripts, testing</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The easiest way to verify that the <tt?>%pre</tt?> scripts we defined for
each package were actually used is to simply install each package:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -Uvh foo-2.7-1.i386.rpm</userinput>
foo                    This is the foo package preinstall script
##################################################
#
# <userinput>rpm -Uvh foo-server-2.7-1.i386.rpm</userinput>
foo-server             This is the foo-server subpackage preinstall script
##################################################
#
# <userinput>rpm -Uvh foo-client-2.7-1.i386.rpm</userinput>
foo-client             This is the foo-client subpackage preinstall script
##################################################
#
# <userinput>rpm -Uvh bazlib-5.6-1.i386.rpm</userinput>
bazlib                 This is the bazlib subpackage preinstall script
##################################################
# 
</screen>
</figure>
As expected, the unique <tt?>%pre</tt?> script for each package has been
included.  Of course, if we hadn't wanted to actually install the packages,
we could have used RPM's <tt?>--scripts</tt?> option to display the
scripts:

<figure id="sc-rpm-subpack-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -qp --scripts foo-2.7-1.i386.rpm</userinput>
preinstall script:
echo "This is the foo package preinstall script"

postinstall script:
(none)
preuninstall script:
(none)
postuninstall script:
(none)
verify script:
(none)
#
</screen>
</figure>
This approach might be a bit safer, particularly if installing the newly
built package would disrupt operations on your build system.

<indexterm>
<primary>subpackages!scripts, testing|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>subpackages!testing|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>subpackages|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect3>

</sect2>

</sect1>

</chapter>

