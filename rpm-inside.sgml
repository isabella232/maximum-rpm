  <chapter id="ch-rpm-inside">
    <title>Inside the Spec File</title>

    <indexterm>
      <primary>spec file</primary>
      <secondary>contents of</secondary>
    </indexterm>

    <para>
      In this chapter, we're going to cover the spec file in detail.  There are
      a number of different types of entries that comprise a spec file, and
      every one will be documented here.  The different types of entries are:

      <itemizedlist mark="bullet">
        <listitem>
          <para>
            Comments &mdash; Human-readable notes ignored by RPM.
          </para>
        </listitem>

        <listitem>
          <para>
            Tags &mdash; Define data.
          </para>
        </listitem>

        <listitem>
          <para>
            Scripts &mdash; Contain commands to be executed at specific times.
          </para>
        </listitem>

        <listitem>
          <para>
            Macros &mdash; A method of executing multiple commands easily.
          </para>
        </listitem>

        <listitem>
          <para>
            The <command>%files</command> list &mdash; A list of files to be
            included in the package.
          </para>
        </listitem>

        <listitem>
          <para>
            Directives &mdash; Used in the <command>%files</command> list to
            direct RPM to handle certain files in a specific way.
          </para>
        </listitem>

        <listitem>
          <para>
            Conditionals &mdash; Permit operating system- or
            architecture-specific preprocessing of the spec file.
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Let's start by looking at comments.
    </para>

    <sect1 id="s1-rpm-inside-comments">
      <title>Comments: Notes Ignored by RPM</title>
      <!-- label: inside-comments -->
      <indexterm>
        <primary>spec file</primary>
        <secondary>comments in</secondary>
      </indexterm>

      <para>
        Comments are a way to make RPM ignore a line in the spec file.  The
        contents of a comment line are entirely up to the person writing the
        spec file.
      </para>
      <para>
        To create a comment, enter an octothorp (<command>#</command>) at the
        start of the line.  Any text following the comment character will be
        ignored by RPM.  Here's an example comment:

        <screen width="60">
<computeroutput>
# This is the spec file for playmidi 2.3...
</computeroutput>
        </screen>
        Comments can be placed in any section of the spec file.
      </para>
    </sect1>

    <sect1 id="s1-rpm-inside-tags">
      <title>Tags: Data Definitions</title>
      <indexterm>
        <primary>spec file</primary>
        <secondary>tags in</secondary>
      </indexterm>

      <para>
        Looking at a spec file, the first thing you'll see are a number of
        lines, all following the same basic format:

        <screen width="60">
<computeroutput>
<replaceable>&lt;something&gt;</replaceable>:<replaceable>&lt;something-else&gt;</replaceable>
</computeroutput>
        </screen>
      </para>
      <para>
        The <replaceable>&lt;something&gt;</replaceable> is known as a "tag",
        because it is used by RPM to name or <emphasis>tag</emphasis> some data.
        The tag is separated from its associated data by a colon.  The data is
        represented by the <replaceable>&lt;something-else&gt;</replaceable>
        above.  Tags are grouped together at the top of the spec file, in a
        section known as the preamble.  Here's an example of a tag and its data:

        <screen width="60">
<computeroutput>
Vendor: White Socks Software, Inc.
</computeroutput>
        </screen>
      </para>
      <para>
        In this example, the tag is "<command>Vendor</command>".  Tags are not
        case-sensitive &mdash; they may be all uppercase, all lowercase, or
        anything in-between.  The <command>Vendor</command> tag is used to
        define the name of the organization producing the package.  The data in
        this example is "<command>White Socks Software, Inc.</command>".
        Therefore, RPM will store <command>White Socks Software, Inc.</command>
        as the vendor of the package.
      </para>
      <para>
        Note, also, that spacing between the tag, the colon, and the data is
        unimportant.  Given this, and the case-insensitivity of the tag, each of
        the following lines are equivalent to the one above:

        <screen width="60">
<computeroutput>
VeNdOr : White Socks Software, Inc.
vendor:White Socks Software, Inc.
VENDOR    :    White Socks Software, Inc.
</computeroutput>
        </screen>
      </para>
      <para>
        The bottom line is that you can make tag lines as neat or as ugly as you
        like &mdash; RPM won't mind either way.  Note, however, the tag's data
        may need to be formatted in a particular fashion.  If there are any such
        restrictions, we'll mention them.  Below, we've grouped tags of similar
        functions together for easier reference, starting with the tags that are
        used to create the package name.
      </para>

      <sect2 id="s2-rpm-inside-package-naming-tags">
        <title>Package Naming Tags</title>
        <para>
          The following tags are used by RPM to produce the package's final
          name.  Since the name is always in the format:

          <screen width="60">
<computeroutput>
<replaceable>&lt;name&gt;</replaceable>-<replaceable>&lt;version&gt;</replaceable>-<replaceable>&lt;release&gt;</replaceable>
</computeroutput>
          </screen>
        </para>
        <para>
          it's only natural that the three tags are known as
          <command>name</command>, <command>version</command>, and
          <command>release</command>.
        </para>

        <sect3 id="s3-rpm-inside-name-tag">
          <title>The <command>name</command> Tag</title>
          <!-- label: inside-name -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>name</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>name</command> tag</primary>
          </indexterm>

          <para>
            The <command>name</command> tag is used to define the name of the
            software being packaged.  In most (if not all) cases, the name used
            for a package should be identical in spelling and case to the
            software being packaged.  The name cannot contain any whitespace: If
            it does, RPM will only use the first part of the name (up to the
            first space).  Therefore, if the name of the software being packaged
            is <application>cdplayer</application>, the <command>name</command>
            tag should be something like:

            <screen width="60">
<computeroutput>
Name: cdplayer
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-version-tag">
          <title>The <command>version</command> Tag</title>
          <!-- label: inside-version -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>version</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>version</command> tag</primary>
          </indexterm>

          <para>
            The <command>version</command> tag defines the version of the
            software being packaged.  The version specified should be as close
            as possible to the format of the original software's version.  In
            most cases, there should be no problem specifying the version just
            as the software's original developer did.  However, there is a
            restriction.  There can be no dashes in the version.  If you forget,
            RPM will remind you:

            <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Illegal '-' char in version: 1.0-a
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Spaces in the version will also cause problems, in that anything
            after the first space will be ignored by RPM.  Bottom line: Stick
            with alphanumeric characters and periods, and you'll never have to
            worry about it.  Here's a sample <command>version</command> tag:

            <screen width="60">
<computeroutput>
Version: 1.2
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-release-tag">
          <title>The <command>release</command> Tag</title>
          <!-- label: inside-release -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>release</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>release</command> tag</primary>
          </indexterm>

          <para>
            The <command>release</command> tag can be thought of as the
            <emphasis>package's</emphasis> version.  The release is
            traditionally an integer &mdash; for example, when a specific piece
            of software at a particular version is first packaged, the release
            should be "<command>1</command>".  If it is necessary to repackage
            that software at the same version, the release should be
            incremented.  When a new version of the software becomes available,
            the release should drop back to "<command>1</command>" when it is
            first packaged.
          </para>
          <para>
            Note that we used the word "traditionally", above.  The only hard
            and fast restriction to the release format is that there can be no
            dashes in it.  Be aware that if you buck tradition, your users may
            not understand what your release means.
          </para>
          <para>
            It is up to the package builder to determine which build represents
            a new release and to update the release manually.  Here is what a
            typical <command>release</command> tag might look like:

            <screen width="60">
<computeroutput>
Release: 5
</computeroutput>
            </screen>
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-descriptive-tags">
        <title>Descriptive Tags</title>

        <para>
          These tags provide information primarily for people who want to know a
          bit more about the package, and who produced it.  They are part of the
          package file, and most of them can be seen by issuing an <command>rpm
          -qi</command> command.
        </para>

        <sect3 id="s3-rpm-inside-description-tag">
          <title>The <command>%description</Command> Tag</title>
          <!-- label: inside-description -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>%description</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>%description</command> tag</primary>
          </indexterm>

          <para>
            The <command>%description</command> tag is used to provide an
            in-depth description of the packaged software.  The description
            should be several sentences describing, to an uninformed user, what
            the software does.
          </para>
          <para>
            The <command>%description</command> tag is a bit different than the
            other tags in the preamble.  For one, it starts with a percent sign.
            The other difference is that the data specified by the
            <command>%description</command> tag can span more than one line.  In
            addition, a primitive formatting capability exists.  If a line
            starts with a space, that line will be displayed verbatim by RPM.
            Lines that do not start with a space are assumed to be part of a
            paragraph and will be formatted by RPM.  It's even possible to mix
            and match formatted and unformatted lines.  Here are some examples:

            <screen width="60">
<computeroutput>
%description
It slices!  It dices!  It's a CD player app that can't be beat.  By using
the resonant frequency of the CD itself, it is able to simulate 20X
oversampling.  This leads to sound quality that cannot be equaled with
more mundane software...
</computeroutput>
            </screen>
          </para>
          <para>
            The example above contains no explicit formatting.  RPM will format
            the text as a single paragraph, breaking lines as needed.

            <screen width="60">
<computeroutput>
%description
 It slices!
 It dices!
 It's a CD player app that can't be beat.
By using the resonant frequency of the CD itself, it is able to simulate
20X oversampling.  This leads to sound quality that cannot be equaled with
more mundane software...
</computeroutput>
            </screen>
          </para>
          <para>
            In this example, the first three lines will be displayed by RPM,
            verbatim.  The remainder of the text will be formatted by RPM.  The
            text will be formatted as one paragraph.

            <screen width="60">
<computeroutput>
%description
 It slices!
 It dices!
 It's a CD player app that can't be beat.

By using the resonant frequency of the CD itself, it is able to simulate
20X oversampling.  This leads to sound quality that cannot be equaled with
more mundane software...
</computeroutput>
            </screen>
          </para>
          <para>
            Above, we have a similar situation to the previous example, in that
            part of the text is formatted and part is not.  However, the blank
            line separates the text into two paragraphs.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-summary-tag">
          <title>The <command>summary</command> Tag</title>
          <!-- label: inside-summary -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>summary</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>summary</command> tag</primary>
          </indexterm>

          <para>
            The <command>summary</command> tag is used to define a one-line
            description of the packaged software.  Unlike
            <command>%description</command>, <command>summary</command> is
            restricted to one line.  RPM uses it when a succinct description of
            the package is needed.  Here is an example of a
            <command>summary</command> line:

            <screen width="60">
<computeroutput>
Summary: A CD player app that rocks!
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-license-tag">
          <title>The <command>license</command> Tag</title>
          <!-- label: inside-license -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>license</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>license</command> tag</primary>
          </indexterm>

          <para>
            The <command>license</command> tag is used to define the license
            terms applicable to the software being packaged.  This tag is also
            known as the <command>copyright</command> tag. In many cases,
            this might be nothing more than "<command>GPL</command>", for
            software distributed under the terms of the GNU General Public
            License, or something similar.  For example:

            <screen width="60">
<computeroutput>
License: GPL
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-distribution-tag">
          <title>The <command>distribution</command> Tag</title>
          <!-- label: inside-distribution -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>distribution</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>distribution</command> tag</primary>
          </indexterm>

          <para>
            The <command>distribution</command> tag is used to define a group of
            packages, of which this package is a part.  Since &RHI; is in the
            business of producing a group of packages known as a Linux
            <emphasis>distribution</emphasis>, the name stuck.  For example, if
            a suite of applications known as "Doors '95" were produced, each
            package that is part of the suite would define its
            <command>distribution</command> line like this:

            <screen width="60">
<computeroutput>
Distribution: Doors '95
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-icon-tag">
          <title>The <command>icon</command> Tag</title>
          <!-- label: inside-icon -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>icon</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>icon</command> tag</primary>
          </indexterm>

          <para>
            The <command>icon</command> tag is used to name a file containing an
            icon representing the packaged software.  The file may be in either
            GIF or XPM format, although XPM is preferred.  In either case, the
            background of the icon should be transparent.  The file should be
            placed in RPM's <filename>SOURCES</filename> directory prior to
            performing a build, so no path is needed.
          </para>
          <para>
            The icon is normally used by graphically-oriented front ends to RPM.
            RPM itself doesn't use the icon, but it's stored in the package file
            and retained in RPM's database after the package is installed.  An
            example <command>icon</command> tag might look like:

            <screen width="60">
<computeroutput>
Icon: foo.xpm
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-vendor-tag">
          <title>The <command>vendor</command> Tag</title>
          <!-- label: inside-vendor -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>vendor</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>vendor</command> tag</primary>
          </indexterm>

          <para>
            The <command>vendor</command> tag is used to define the name of the
            entity that is responsible for packaging the software.  Normally,
            this would be the name of an organization.  Here's an example:

            <screen width="60">
<computeroutput>
Vendor: White Socks Software, Inc.
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-url-tag">
          <title>The <command>url</command> Tag</title>
          <!-- label: inside-url -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>url</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>url</command> tag</primary>
          </indexterm>

          <indexterm>
            <primary>URL</primary>
          </indexterm>

          <para>
            The <command>url</command> tag is used to define a Uniform Resource
            Locator that can be used to obtain additional information about the
            packaged software.  At present, RPM doesn't actively make use of
            this tag.  The data is stored in the package however, and will be
            written into RPM's database when the package is installed.  It's
            only a matter of time before some web-based RPM adjunct makes use of
            this information, so make sure you include URLs!  Something like
            this is all you'll need:

            <screen width="60">
<computeroutput>
URL: http://www.gnomovision.com/cdplayer.html
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-group-tag">
          <title>The <command>group</command> Tag</title>
          <!-- label: inside-group -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>group</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>group</command> tag</primary>
          </indexterm>

          <para>
            The <command>group</command> tag is used to group packages together
            by the types of functionality they provide.  The group specification
            looks like a path and is similar in function, in that it specifies
            more general groupings before more detailed ones.  For example, a
            package containing a text editor might have the following group:

            <screen width="60">
<computeroutput>
Group: Applications/Editors
</computeroutput>
            </screen>
          </para>
          <para>
            In this example, the package is part of the
            <filename>Editors</filename> group, which is itself a part of the
            <filename>Applications</filename> group.  Likewise, a spreadsheet
            package might have this group:

            <screen width="60">
<computeroutput>
Group: Applications/Spreadsheets
</computeroutput>
            </screen>
          </para>
          <para>
            This <command>group</command> tag indicates that under the
            <filename>Applications</filename> group, we would find
            <filename>Editors</filename> and <filename>Spreadsheets</filename>,
            and probably some other subgroups as well.
          </para>
          <para>
            How is this information used?  It's primarily meant to permit
            graphical front-ends to RPM, to display packages in a hierarchical
            fashion.  Of course, in order for groups to be as effective as
            possible, it's necessary for all package builders to be consistent
            in their groupings.  In the case of packages for Linux, &RHI; has
            the definitive list.  Therefore, Linux package builders should give
            serious consideration to using &RHI;'s groups.  The current group
            hierarchy is installed with every copy of RPM, and is available in
            the RPM sources as well.  Check out the file
            <filename>groups</filename> in RPM's documentation directory
            (normally
            <filename>/usr/share/doc/rpm-<replaceable>&lt;version&gt;</replaceable></filename>),
            or in the top-level source directory.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-packager-tag">
          <title>The <command>packager</command> Tag</title>
          <!-- label: inside-packager -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>packager</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>packager</command> tag</primary>
          </indexterm>

          <para>
            The <command>packager</command> tag is used to hold the name and
            contact information for the person or persons who built the package.
            Normally, this would be the person that actually built the package,
            or in a larger organization, a public relations contact.  In either
            case, contact information such as an e-mail address or phone number
            should be included, so customers can send either money or hate mail,
            depending on their satisfaction with the packaged software.  Here's
            an example of a <command>packager</command> tag:

            <screen width="60">
<computeroutput>
Packager: Fred Foonly &lt;fred@gnomovision.com&gt;
</computeroutput>
            </screen>
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-dependency-tags">
        <title>Dependency Tags</title>
        <para>
          One RPM feature that's been recently implemented is a means of
          ensuring that if a package is installed, the system environment has
          everything the package requires in order to operate properly.
          Likewise, when an installed package is erased RPM can make sure no
          other package relies on the package being erased.  This dependency
          capability can be very helpful when end users install and erase
          packages on their own.  It makes it more difficult for them to paint
          themselves into a corner, package-wise.
        </para>
        <para>
          However, in order for RPM to be able to take more than basic
          dependency information into account, the package builder must add the
          appropriate dependency information to the package.  This is done by
          using the following tags.  Note, however, that adding dependency
          information to a package requires some forethought.  For additional
          information on RPM's dependency processing, please review <xref
          linkend="ch-rpm-depend">.
        </para>

        <sect3 id="s3-rpm-inside-provides-tag">
          <title>The <command>provides</command> Tag</title>
          <!-- label: inside-provides -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>provides</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>provides</command> tag</primary>
          </indexterm>

          <para>
            The <command>provides</command> tag is used to specify a
            <firstterm>virtual package</firstterm> that the packaged software
            makes available when it is installed.  Normally, this tag would be
            used when different packages provide equivalent services.  For
            example, any package that allows a user to read mail might provide
            the <application>mail-reader</application> virtual package.  Another
            package that depends on a mail reader of some sort, could require
            the <application>mail-reader</application> virtual package.  It would then
            install without dependency problems, if any one of several mail
            programs were installed.  Here's what a <command>provides</command>
            tag might look like:

            <screen width="60">
<computeroutput>
Provides: mail-reader
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-requires-tag">
          <title>The <command>requires</command> Tag</title>
          <!-- label: inside-requires -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>requires</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>requires</command> tag</primary>
          </indexterm>

          <para>
            The <command>requires</command> tag is used to alert RPM to the fact
            that the package needs to have certain capabilities available in
            order to operate properly.  These capabilities refer to the name of
            another package, or to a virtual package provided by one or more
            packages that use the <command>provides</command> tag.  When the
            <command>requires</command> tag references a package name, version
            comparisons may also be included by following the package name with
            <command>&lt;</command>, <command>&gt;</command>,
            <command>=</command>, <command>&gt;=</command>, or
            <command>&lt;=</command>, and a version specification.  To get even
            more specific, a package's release may be included as well.  Here's
            a <command>requires</command> tag in action, with a specific version
            requirement:

            <screen width="60">
<computeroutput>
Requires: playmidi = 2.3
</computeroutput>
            </screen>
          </para>
          <para>
            If the <command>Requires</command> tag needs to perform a comparison
            against an epoch number defined with the <command>epoch</command>
            tag (described below), then the proper format would be:

            <screen width="60">
<computeroutput>
Requires: playmidi =S 4
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-conflicts-tag">
          <title>The <command>conflicts</command> Tag</title>
          <!-- label: inside-conflicts -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>conflicts</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>conflicts</command> tag</primary>
          </indexterm>

          <para>
            The <command>conflicts</command> tag is the logical complement to
            the <command>requires</command> tag.  The
            <command>requires</command> tag is used to specify what packages
            <emphasis>must</emphasis> be present in order for the current
            package to operate properly.  The <command>conflicts</command> tag
            is used to specify what packages <emphasis>cannot</emphasis> be
            installed if the current package is to operate properly.
          </para>
          <para>
            The <command>conflicts</command> tag has the same format as the
            <command>requires</command> tag &mdash; namely, the tag is followed
            by a real or virtual package name.  Like
            <command>requires</command>, the <command>conflicts</command> tag
            also accepts version and release specifications:

            <screen width="60">
<computeroutput>
Conflicts: playmidi = 2.3-1
</computeroutput>
            </screen>
          </para>
          <para>
            If the <command>conflicts</command> tag needs to perform a
            comparison against an epoch number defined with the
            <command>epoch</command> tag (described below), then the proper
            format would be:

            <screen width="60">
<computeroutput>
Conflicts: playmidi =S 4
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-epoch-tag">
          <title>The <command>epoch</command> Tag</title>
          <!-- label: inside-epoch -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>epoch</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>epoch</command> tag</primary>
          </indexterm>

          <para>
            The <command>epoch</command> tag is another part of RPM's
            dependency and upgrade processing.  It is also known as the
            <command>serial</command> tag.  The need for it is somewhat
            obscure, but goes something like this:

            <orderedlist>
              <listitem>
                <para>
                  The package being built (call it package
                  <replaceable>A</replaceable>) uses a version numbering scheme
                  sufficiently obscure so that RPM cannot determine if one
                  version is older or newer than another version.
                </para>
              </listitem>

              <listitem>
                <para>
                  Another package (package <replaceable>B</replaceable>)
                  requires that package <replaceable>A</replaceable> be
                  installed.  More specifically, it requires RPM to compare
                  package <replaceable>A</replaceable>'s version against a
                  specified minimum (or maximum) version.
                </para>
              </listitem>
            </orderedlist>
          </para>

          <para>
            Since RPM is unable to compare package
            <replaceable>A</replaceable>'s version against the version specified
            by package <replaceable>B</replaceable>, there is no way to
            determine if package <replaceable>B</replaceable>'s dependency
            requirements can be met.  What to do?
          </para>
          <para>
            The <command>epoch</command> tag provides a way to get around this
            tricky problem.  By specifying a simple integer epoch number for
            each version, you are, in essence, directing how RPM interprets the
            relative age of the package.  The key point to keep in mind is that
            in order for this to work, a unique epoch number must be defined
            for each version of the software being packaged.  In addition, the
            epoch number must increment along with the version.  Finally, the
            package that requires the epoched software needs to specify
            <emphasis>its</emphasis> version requirements in terms of the epoch
            number.
          </para>
          <para>
            Does it sound like a lot of trouble?  You're right!  If you find
            yourself in the position of needing to use this tag, take a deep
            breath and seriously consider changing the way you assign version
            numbers.  If you're packaging someone else's software, perhaps you
            can convince them to make the change.  Chances are, if RPM can't
            figure out the version number, most people can't, either!  An
            example <command>epoch</command> tag would look something like
            this:

            <screen width="60">
<computeroutput>
Epoch: 4
</computeroutput>
            </screen>
          </para>
          <para>
            Note that RPM considers a package with an epoch number as newer than
            a package without an epoch number.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-autoreqprov-tag">
          <title>The <command>autoreqprov</command> Tag</title>
          <!-- label: inside-autoreqprov -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>autoreqprov</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>autoreqprov</command> tag</primary>
          </indexterm>

          <para>
            The <command>autoreqprov</command> tag is used to control the
            automatic dependency processing performed when the package is being
            built.  Normally, as each package is built, the following steps are
            performed:

            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  All executable programs being packaged are analyzed to
                  determine their shared library requirements.  These
                  requirements are automatically added to the package's
                  requirements.
                </para>
              </listitem>

              <listitem>
                <para>
                  The soname of each shared library being packaged is
                  automatically added to the package's list of "provides"
                  information.
                </para>
              </listitem>
            </itemizedlist>
          </para>

          <para>
            By doing this, RPM reduces the need for package builders to manually
            add dependency information to their packages.  However, there are
            times when RPM's automatic dependency processing may not be
            desirable.  In those cases the <command>autoreqprov</command> tag
            can be used to disable automatic dependency processing.
          </para>
          <para>
            To disable automatic dependency processing, add the following line:

            <screen width="60">
<computeroutput>
AutoReqProv: no
</computeroutput>
            </screen>
          </para>
          <para>
            (The number zero may be used instead of <command>no</command>)
            Although RPM defaults to performing automatic dependency processing,
            the effect of the <command>autoreqprov</command> tag can be reversed
            by changing <command>no</command> to <command>yes</command>.  (The
            number one may be used instead of <command>yes</command>)
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-arch-and-os-tags">
        <title>Architecture- and Operating System-Specific Tags</title>

        <para>
          As RPM gains in popularity, more people are putting it to work on
          different types of computer systems.  While this would not normally be
          a problem, things start to get a little tricky when one of the
          following two situations becomes commonplace:

          <orderedlist>
            <listitem>
              <para>
                A particular operating system is ported to several different
                hardware platforms, or architectures.
              </para>
            </listitem>

            <listitem>
              <para>
                A particular architecture runs several different operating
                systems.
              </para>
            </listitem>
          </orderedlist>
        </para>

        <para>
          The real bind hits when RPM is used to package software for several of
          these different system environments.  Without methods of controlling
          the build process based on architecture and operating system, package
          builders that develop software for more than one architecture or
          operating system will have a hard time indeed.  The only alternative
          would be to maintain parallel RPM build environments and accept all
          the coordination headaches that would entail.
        </para>
        <para>
          Fortunately, RPM makes it all easier than that.  With the following
          tags, it's possible to support package building under multiple
          environments, all from a single set of sources, patches, and a single
          spec file.  For a more complete discussion of multi-architecture
          package building, please see <xref linkend="ch-rpm-multi">.
        </para>

        <sect3 id="s3-rpm-inside-excludearch-tag">
          <title>The <command>excludearch</command> Tag</title>
          <!-- label: inside-excludearch -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>excludearch</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>excludearch</command> tag</primary>
          </indexterm>

          <para>
            The <command>excludearch</command> tag directs RPM to ensure that
            the package does <emphasis>not</emphasis> attempt to build on the
            excluded architecture(s).  The reasons for preventing a package from
            building on a certain architecture might include:

            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  The software has not yet been ported to the excluded
                  architecture.
                </para>
              </listitem>

              <listitem>
                <para>
                  The software would serve no purpose on the excluded
                  architecture.
                </para>
              </listitem>
            </itemizedlist>
          </para>

          <para>
            An example of the first case might be that the software was designed
            based on the assumption that an integer is a 32-bit quantity.
            Obviously, this assumption is not valid on a 64-bit processor.
          </para>
          <para>
            In the second case, software that depended on or manipulated
            low-level features of a given architecture, should be excluded from
            building on a different architecture.  Assembly language programs
            would fall into this category.
          </para>
          <para>
            One or more architectures may be specified after the
            <command>excludearch</command> tag, separated by either spaces or
            commas.  Here is an example:

            <screen width="60">
<computeroutput>
ExcludeArch: sparc alpha
</computeroutput>
            </screen>
          </para>
          <para>
            In this example, RPM would not attempt to build the package on
            either the Sun SPARC or Digital Alpha/AXP architectures.  The
            package would build on any other architectures, however.  If a build
            is attempted on an excluded architecture, the following message will
            be displayed, and the build will fail:

            <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba cdplayer-1.0.spec</command>
<computeroutput>
Arch mismatch!
cdplayer-1.0.spec doesn't build on this architecture
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Note that if your goal is to ensure that a package will only build
            on <emphasis>one</emphasis> architecture, then you should use the
            <command>exclusivearch</command> tag.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-exclusivearch-tag">
          <title>The <command>exclusivearch</command> Tag</title>
          <!-- label: inside-exclusivearch -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>exclusivearch</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>exclusivearch</command> tag</primary>
          </indexterm>

          <para>
            The <command>exclusivearch</command> tag is used to direct RPM to
            ensure the package is <emphasis>only</emphasis> built on the
            specified architecture(s).  The reasons for this are similar to the
            those mentioned in the section on the <command>excludearch</command>
            tag above.  However, the <command>exclusivearch</command> tag is
            useful when the package builder needs to ensure that
            <emphasis>only</emphasis> the specified architectures will build the
            package.  This tag ensures that no future architectures will
            mistakenly attempt to build the package.  This would not be the case
            if the <command>excludearch</command> tag were used to specify every
            architecture known at the time the package is built.
          </para>
          <para>
            The syntax of the <command>exclusivearch</command> tag is identical
            to that of <command>excludearch</command>:

            <screen width="60">
<computeroutput>
ExclusiveArch: sparc alpha
</computeroutput>
            </screen>
          </para>
          <para>
            In this example, the package will only build on a Sun SPARC or
            Digital Alpha/AXP system.
          </para>
          <para>
            Note that if your goal is to ensure that a package will
            <emphasis>not</emphasis> build on specific architectures, then you
            should use the <command>excludearch</command> tag.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-excludeos">
          <title>The <command>excludeos</command> Tag</title>
          <!-- label: inside-excludeos -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>excludeos</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>excludeos</command> tag</primary>
          </indexterm>

          <para>
            The <command>excludeos</command> tag is used to direct RPM to ensure
            that the package does <emphasis>not</emphasis> attempt to build on
            the excluded operating system(s).  This is usually necessary when a
            package is to be built on more than one operating system, but it is
            necessary to keep a particular operating system from attempting a
            build.
          </para>
          <para>
            Note that if your goal is to ensure that a package will only build
            on <emphasis>one</emphasis> operating system, then you should use
            the <command>exclusiveos</command> tag.  Here's a sample
            <command>excludeos</command> tag:

            <screen width="60">
<computeroutput>
ExcludeOS: linux irix
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-exclusiveos-tag">
          <title>The <command>exclusiveos</command> Tag</title>
          <!-- label: inside-exclusiveos -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>exclusiveos</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>exclusiveos</command> tag</primary>
          </indexterm>

          <para>
            The <command>exclusiveos</command> tag has the same syntax as
            <command>excludeos</command>, but it has the opposite logic.  The
            <command>exclusiveos</command> tag is used to denote which operating
            system(s) should <emphasis>only</emphasis> be be permitted to build
            the package.  Here's <command>exclusiveos</command> in action:

            <screen width="60">
<computeroutput>
ExclusiveOS: linux
</computeroutput>
            </screen>
          </para>
          <para>
            Note that if your goal is to ensure that a package will
            <emphasis>not</emphasis> build on a specific operating system, then
            you should use the <command>excludeos</command> tag.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-directory-related-tags">
        <title>Directory-related Tags</title>

        <para>
          A number of tags are used to specify directories and paths that are
          used in various phases of RPM's build and install processes.  There's
          not much more to say collectively about these tags, so let's dive
          right in and look them over.
        </para>

        <sect3 id="s3-rpm-inside-prefix-tag">
          <title>The <command>prefix</command> Tag</title>
          <!-- label: inside-prefix -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>prefix</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>prefix</command> tag</primary>
          </indexterm>

          <para>
            The <command>prefix</command> tag is used when a relocatable package
            is to be built.  A relocatable package can be installed normally or
            can be installed in a user-specified directory, by using RPM's
            <command>--prefix</command> install-time option.  The data specified
            after the <command>prefix</command> tag should be the part of the
            package's path that may be changed during installation.  For
            example, if the following <command>prefix</command> line was
            included in a spec file:

            <screen width="60">
<computeroutput>
Prefix: /opt
</computeroutput>
            </screen>
          </para>
          <para>
            and the following file was specified in the spec file's
            <command>%files</command> list:

            <screen width="60">
<computeroutput>
/opt/blather/foonly
</computeroutput>
            </screen>
          </para>
          <para>
            then the file <filename>foonly</filename> would be installed in
            <filename>/opt/blather</filename> if the package was installed
            normally.  It would be installed in
            <filename>/usr/local/blather</filename> if the package was installed
            with the <command>--prefix <filename>/usr/local</filename></command>
            option.
          </para>
          <para>
            For more information about creating relocatable packages, see <xref
            linkend="ch-rpm-reloc">.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-buildroot-tag">
          <title>The <command>buildroot</command> Tag</title>
          <!-- label: inside-buildroot -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>buildroot</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>buildroot</command> tag</primary>
          </indexterm>

          <para>
            The <command>buildroot</command> tag is used to define an alternate
            build root.  The name is a bit misleading, as the build root is
            actually used when the software is <emphasis>installed</emphasis>
            during the build process.  In order for a build root to be defined
            and actually used, a number of issues must be taken into account.
            These issues are covered in <xref linkend="ch-rpm-anywhere">.  This
            is what a <command>buildroot</command> tag would look like:

            <screen width="60">
<computeroutput>
BuildRoot: /tmp/cdplayer
</computeroutput>
            </screen>
          </para>
          <para>
            The <command>buildroot</command> tag can be overridden at build-time
            by using the <command>--buildroot</command> command-line option.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-source-and-patch-tags">
        <title>Source and Patch Tags</title>

        <para>
          In order to build and package software, RPM needs to know where to
          find the original sources.  But it's not quite that simple.  There
          might be more than one set of sources that need to be part of a
          particular build.  In some cases, it might be necessary to prevent
          some sources from being packaged.
        </para>
        <para>
          And then there is the matter of patches.  It's likely that changes
          will need to be made to the sources, so it's necessary to specify a
          patch file.  But the same issues that apply to source specifications
          are also applicable to patches.  There might be more than one set of
          patches required.
        </para>
        <para>
          The tags that follow are crucial to RPM, so it pays to have a firm
          grasp of how they are used.
        </para>

        <sect3 id="s3-rpm-inside-source-tag">
          <title>The <command>source</command> Tag</title>
          <!-- label: inside-source -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>source</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>source</command> tag</primary>
          </indexterm>

          <para>
            The <command>source</command> tag is central to nearly every spec
            file.  Although it has only one piece of data associated with it, it
            actually performs two functions:

            <orderedlist>
              <listitem>
                <para>
                  It shows where the software's developer has made the original
                  sources available.
                </para>
              </listitem>

              <listitem>
                <para>
                  It gives RPM the name of the original source file.
                </para>
              </listitem>
            </orderedlist>
          </para>

          <para>
            While there is no hard and fast rule, for the first function, it's
            generally considered best to put this information in the form of a
            Uniform Resource Locator (URL).
            <indexterm>
              <primary>URL</primary>
            </indexterm>
            The URL should point directly to the source file itself.  This is
            due to the <command>source</command> tag's second function.
          </para>
          <para>
            As mentioned above, the <command>source</command> tag also needs to
            direct RPM to the source file on the build system.  How does it do
            this?  There's only one requirement, and it is ironclad: The source
            filename must be at the end of the line as the final element in a
            path.  Here's an example:

            <screen width="60">
<computeroutput>
Source: ftp://ftp.gnomovision.com/pub/cdplayer-1.0.tgz
</computeroutput>
            </screen>
          </para>

          <para>
            Given this <command>source</command> line, RPM will search its
            <filename>SOURCES</filename> directory for
            <filename>cdplayer-1.0.tgz</filename>.  Everything prior to the
            filename is ignored by RPM.  It's there strictly for any interested
            humans.
          </para>
          <para>
            A spec file may contain more than one <command>source</command> tag.
            This is necessary for those cases where the software being packaged
            is contained in more than one source file.  However, the
            <command>source</command> tags must be uniquely identified.  This is
            done by appending a number to the end of the tag itself.  In fact,
            RPM does this internally for the first <command>source</command> tag
            in a spec file, in essence turning it into
            <command>source0</command>.  Therefore, if a package contains two
            source files, they may either be specified as:

            <screen width="60">
<computeroutput>
Source: blather-4.5.tar.gz
Source1: bother-1.2.tar.gz
</computeroutput>
            </screen>
          </para>
          <para>
            or as:

            <screen width="60">
<computeroutput>
Source0: blather-4.5.tar.gz
Source1: bother-1.2.tar.gz
</computeroutput>
            </screen>
          </para>
          <para>
            Either approach may be used.  The choice is yours.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-nosource-tag">
          <title>The <command>nosource</command> Tag</title>
          <!-- label: rpm-nosource -->
          <!-- label: inside-nosource -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>nosource</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>nosource</command> tag</primary>
          </indexterm>

          <para>
            The <command>nosource</command> tag is used to direct RPM to omit
            one or more source files from the source package.  Why would someone
            want to go to the trouble of specifying a source file, only to
            exclude it?  The reasons for this can be varied, but let's look at
            one example: The software known as Pretty Good Privacy, or PGP.
          </para>
          <para>
            PGP contains encryption routines of such high quality that the
            United States government restricts their export.
            <footnote>
              <para>
                There is also an "international" version that may be used in
                non-US countries.  See <xref linkend="ch-pgp-intro">.
              </para>
            </footnote>
            While it would be nice to create a PGP package file, the resulting
            package could not legally be transferred between the U.S. and other
            countries, or vice-versa.
          </para>
          <para>
            However, what if all files other than the original source, were
            packaged using RPM?  Well, a binary package made without PGP would
            be of little use, but what about the source package?  It would
            contain the spec file, maybe some patches, and perhaps even an icon
            file.  Since the controversial PGP software was not a part of the
            source package, this sanitized source package could be downloaded
            legally in any country.  The person that downloaded a copy could
            then go about legally obtaining the PGP sources themselves, place
            them in RPM's <filename>SOURCES</filename> directory, and create a
            binary package.  They wouldn't even need to change the
            <command>nosource</command> tag.  One &rpmb; <command>-ba</command>
            command later, and the user would have a perfectly usable PGP binary
            package file.
          </para>
          <para>
            Since there may be more than one <command>source</command> tag in a
            spec file, the format of the <command>nosource</command> tag is as
            follows:

            <screen width="60">
<computeroutput>
nosource: <replaceable>&lt;src-num&gt;</replaceable>, <replaceable>&lt;src-num&gt;</replaceable>&hellip;<replaceable>&lt;src-num&gt;</replaceable>
</computeroutput>
            </screen>
          </para>
          <para>
            The <command><replaceable>&lt;src-num&gt;</replaceable></command>
            represents the number following the <command>source</command> tag.
            If there is more than one number in the list, they may be separated
            by either commas or spaces.  For example, consider a package
            containing the following <command>source</command> tags:

            <screen width="60">
<computeroutput>
source: blather-4.5.tar.gz
Source1: bother-1.2.tar.gz
source2: blather-lib-4.5.tar.gz
source3: bother-lib-1.2.tar.gz
</computeroutput>
            </screen>
          </para>
          <para>
            If the source files for <application>blather</application> and
            <application>blather-lib</application> were not to be included in the
            package, the following <command>nosource</command> line could be
            added:

            <screen width="60">
<computeroutput>
NoSource: 0, 3
</computeroutput>
            </screen>
          </para>
          <para>
            What about that <command>0</command>?  Keep in mind that the first
            unnumbered <command>source</command> tag in a spec file is
            automatically numbered 0 by RPM.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-patch-tag">
          <title>The <command>patch</command> Tag</title>
          <!-- label: inside-patch -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>patch</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>patch</command> tag</primary>
          </indexterm>

          <para>
            The <command>patch</command> tag is used to identify which patches
            are associated with the software being packaged.  The patch files
            are kept in RPM's <filename>SOURCES</filename> directory, so only
            the name of the patch file should be specified.  Here is an example:

            <screen width="60">
<computeroutput>
Patch: cdp-0.33-fsstnd.patch
</computeroutput>
            </screen>
          </para>
          <para>
            There are no hard and fast requirements for naming the patch files,
            but traditionally the filename starts with the software name and
            version, separated by dashes.  The next part of the patch file name
            usually includes one or more words indicating the reason for the
            patch.  In our example above, the patch file contains changes
            necessary to bring the software into compliance with the Linux File
            System Standard, hence the <computeroutput>fsstnd</computeroutput>
            magic incantation.
          </para>
          <para>
            RPM processes <command>patch</command> tags the same way it does
            <command>source</command> tags.  Therefore, it's acceptable to use a
            Uniform Resource Locator (URL)
            <indexterm>
              <primary>URL</primary>
            </indexterm>
            on a <command>patch</command> line, too.
          </para>
          <para>
            A spec file may contain more than one <command>patch</command> tag.
            This is necessary for those cases where the software being packaged
            requires more than one patch.  However, the <command>patch</command>
            tags must be uniquely identified.  This is done by appending a
            number to the end of the tag itself.  In fact, RPM does this
            internally for the first <command>patch</command> tag in a spec
            file, in essence turning it into <command>patch0</command>.
            Therefore, if a package contains three patches, the following two
            methods of specifying them are equivalent:

            <screen width="60">
<computeroutput>
Patch: blather-4.5-bugfix.patch
Patch1: blather-4.5-config.patch
Patch2: blather-4.5-somethingelse.patch
</computeroutput>
            </screen>
          </para>
          <para>
            This is the same as:

            <screen width="60">
<computeroutput>
Patch0: blather-4.5-bugfix.patch
Patch1: blather-4.5-config.patch
Patch2: blather-4.5-somethingelse.patch
</computeroutput>
            </screen>
          </para>
          <para>
            Either approach may be used, but the second method looks nicer.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-nopatch-tag">
          <title>The <command>nopatch</command> Tag</title>
          <!-- label: inside-nopatch -->
          <indexterm>
            <primary>tags</primary>
            <secondary><command>nopatch</command></secondary>
          </indexterm>

          <indexterm>
            <primary><command>nopatch</command> tag</primary>
          </indexterm>

          <para>
            The <command>nopatch</command> tag is similar to the
            <command>nosource</command> tag discussed earlier.  Just like the
            <command>nosource</command> tag, the <command>nopatch</command> tag
            is used to direct RPM to omit something from the source package.  In
            the case of <command>nosource</command>, that "something" was one or
            more sources.  For the <command>nopatch</command> tag, the
            "something" is one or more patches.
          </para>
          <para>
            Since each <command>patch</command> tag in a spec file must be
            numbered, the <command>nopatch</command> tag uses those numbers to
            specify which patches are not to be included in the package.  The
            <command>nopatch</command> tag is used in this manner:

            <screen width="60">
<computeroutput>
NoPatch: 2 3
</computeroutput>
            </screen>
          </para>
          <para>
            In this example, the source files specified on the
            <command>source2</command> and <command>source3</command> lines are
            not to be included in the build.
          </para>
          <para>
            This concludes our study of RPM's tags.  In the next section, we'll
            look at the various scripts that RPM uses to build, as well as to
            install, and erase, packages.
          </para>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-inside-scripts">
      <title>Scripts: RPM's Workhorse</title>
      <indexterm>
        <primary>spec file</primary>
        <secondary>scripts in</secondary>
      </indexterm>

      <para>
        The scripts that RPM uses to control the build process are among the
        most varied and interesting parts of the spec file.  Many spec files
        also contain scripts that perform a variety of tasks whenever the
        package is installed or erased.
      </para>
      <para>
        The start of each script is denoted by a keyword.  For example, the
        <command>%build</command> keyword marks the start of the script RPM will
        execute when building the software to be packaged.  It should be noted
        that, in the strictest sense of the word, these parts of the spec file
        are not scripts.  For example, they do not start with the traditional
        invocation of a shell.  However, the contents of each script section are
        copied into a file and executed by RPM as a full-fledged script.  This
        is part of the power of RPM: Anything that can be done in a script can
        be done by RPM.
      </para>
      <para>
        Let's start by looking at the scripts used during the build process.
      </para>

      <sect2 id="s2-rpm-inside-build-time-scripts">
        <title>Build-time Scripts</title>
        <!-- label: inside-scripts -->
        <indexterm>
          <primary>scripts</primary>
          <secondary>build-time</secondary>
        </indexterm>

        <para>
          The scripts that RPM uses during the building of a package follow the steps
          known to every software developer:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Unpacking the sources.
              </para>
            </listitem>

            <listitem>
              <para>
                Building the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Installing the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Cleaning up.
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          Although each of the scripts perform a specific function in the build
          process, they share a common environment.  Using RPM's
          <command>--test</command> option
          <footnote>
            <para>
              Described in <xref linkend="s2-rpm-b-command-test-option">.
            </para>
          </footnote>
          , we can see the common portion of each script.  In the following
          example, we've taken the <application>cdplayer</application> package, issued
          an &rpmb; <command>-ba --test cdplayer-1.0-1.spec</command>, and viewed
          the script files left in RPM's temporary directory.  This section
          (with the appropriate package-specific values) is present in every
          script RPM executes during a build:

          <screen width="60">
<computeroutput>
#!/bin/sh -e
# Script generated by rpm

RPM_SOURCE_DIR="/usr/src/redhat/SOURCES"
RPM_BUILD_DIR="/usr/src/redhat/BUILD"
RPM_DOC_DIR="/usr/doc"
RPM_OPT_FLAGS="-O2 -m486 -fno-strength-reduce"
RPM_ARCH="i386"
RPM_OS="Linux"
RPM_ROOT_DIR="/tmp/cdplayer"
RPM_BUILD_ROOT="/tmp/cdplayer"
RPM_PACKAGE_NAME="cdplayer"
RPM_PACKAGE_VERSION="1.0"
RPM_PACKAGE_RELEASE="1"
set -x

umask 022
</computeroutput>
          </screen>
          <indexterm>
            <primary>scripts</primary>
            <secondary>build-time</secondary>
            <tertiary>environment variables in</tertiary>
          </indexterm>
        </para>
        <para>
          As we can see, the script starts with the usual invocation of a shell
          (in this case, the Bourne shell).  There are no arguments passed to
          the script.  Next, a number of environment variables are set.  Here's
          a brief description of each one:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                <envar>RPM_SOURCE_DIR</envar> &mdash; This environment variable
                gets its value from the rpmrc file entry
                <command>sourcedir</command>, which in turn can get part of its
                value from the <command>topdir</command> entry.  It is the path
                RPM will prepend to the file, specified in the
                <command>source</command> tag line.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_BUILD_DIR</envar> &mdash; This variable is based on
                the <command>builddir</command> rpmrc file entry, which in turn
                can get part of its value from the <command>topdir</command>
                entry.  This environment variable translates to the path of
                RPM's build directory, where most software will be unpacked and
                built.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_DOC_DIR</envar> &mdash; The value of this environment
                variable is based on the <command>defaultdocdir</command>
                <filename>rpmrc</filename> file entry.  Files marked with the
                <command>%doc</command> directive can be installed in a
                subdirectory of <command>defaultdocdir</command>.  For more
                information on the <command>%doc</command> directive, refer to
                <xref linkend="s3-rpm-inside-flist-doc-directive">.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_OPT_FLAGS</envar> &mdash; This environment variable
                gets its value from the <command>optflags</command>
                <filename>rpmrc</filename> file entry.  It contains options that
                can be passed on to the build procedures of the software being
                packaged.  Normally this means either a configuration script or
                the <command>make</command> command itself.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_ARCH</envar> &mdash; As one might infer from the
                example above, this environment variable contains a string
                describing the build system's architecture.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_OS</envar> &mdash; This one contains the name of the
                build system's operating system.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_BUILD_ROOT</envar> &mdash; This environment variable
                is used to hold the "build root", into which the newly built
                software will be installed.  If no explicit build root has been
                specified (either by command line option, spec file tag line, or
                rpmrc file entry), this variable will be null.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_PACKAGE_NAME</envar> &mdash; This environment
                variable gets its value from the <command>name</command> tag
                line in the package's spec file.  It contains the name of the
                software being packaged.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_PACKAGE_VERSION</envar> &mdash; The
                <command>version</command> tag line is the source of this
                variable's translation.  Predictably, this environment variable
                contains the software's version number.
              </para>
            </listitem>

            <listitem>
              <para>
                <envar>RPM_PACKAGE_RELEASE</envar> &mdash; This environment
                variable contains the package's release number.  Its value is
                obtained from the <command>release</command> tag line in the
                spec file.
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          All of these environment variables are set for your use, to make it
          easier to write scripts that will do the right thing even if the build
          environment changes.
        </para>
        <para>
          The script also sets an option that causes the shell to print out each
          command, complete with expanded arguments.  Finally, the default
          permissions are set.  Past this point, the scripts differ.  Let's look
          at the scripts in the order they are executed.
        </para>

        <sect3 id="s3-rpm-inside-prep-script">
          <title>The <command>%prep</command> Script</title>
          <!-- label: inside-prep -->
          <indexterm>
            <primary><command>%prep</command> script</primary>
          </indexterm>

          <para>
            The <command>%prep</command> script is the first script RPM executes
            during a build.  Prior to the <command>%prep</command> script, RPM
            has performed preliminary consistency checks, such as whether the
            spec file's <command>source</command> tag points to files that
            actually exist.  Just prior to passing control over to the
            <command>%prep</command> script's contents, RPM changes directory
            into RPM's build area, which, by default, is
            <filename>/usr/src/redhat/BUILD</filename>.
          </para>
          <para>
            At that point, it is the responsibility of the
            <command>%prep</command> script to:

            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  Create the top-level build directory.
                </para>
              </listitem>

              <listitem>
                <para>
                  Unpack the original sources into the build directory.
                </para>
              </listitem>

              <listitem>
                <para>
                  Apply patches to the sources, if necessary.
                </para>
              </listitem>

              <listitem>
                <para>
                  Perform any other actions required to get the sources in a
                  ready-to-build state.
                </para>
              </listitem>
            </itemizedlist>
          </para>

          <para>
            The first three items on this list are common to the vast majority
            of all software being packaged.  Because of this, RPM has two macros
            that greatly simplify these routine functions.  More information on
            RPM's <command>%setup</command> and <command>%patch</command> macros
            can be found in <xref linkend="s1-rpm-inside-macros">.
          </para>
          <para>
            The last item on the list can include creating directories or
            anything else required to get the sources in a ready-to-build state.
            As a result, a <command>%prep</command> script can range from one
            line invoking a single <command>%setup</command> macro, to many
            lines of tricky shell programming.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-build-script">
          <title>The <command>%build</command> Script</title>
          <!-- label: inside-build -->
          <indexterm>
            <primary><command>%build</command> script</primary>
          </indexterm>

          <para>
            The <command>%build</command> script picks up where the
            <command>%prep</command> script left off.  Once the
            <command>%prep</command> script has gotten everything ready for the
            build, the <command>%build</command> script is usually somewhat
            anti-climactic &mdash; normally invoking <command>make</command>,
            maybe a configuration script, and little else.
          </para>
          <para>
            Like <command>%prep</command> before it, the
            <command>%build</command> script has the same assortment of
            environment variables to draw on.  Also, like
            <command>%prep</command>, <command>%build</command> changes
            directory into the software's top-level build directory (located in
            <envar>RPM_BUILD_DIR</envar>, or usually called
            <command><replaceable>&lt;name&gt;</replaceable>-<replaceable>&lt;version&gt;</replaceable></command>).
          </para>
          <para>
            Unlike <command>%prep</command>, there are no macros available for
            use in the <command>%build</command> script.  The reason is simple:
            Either the commands required to build the software are simple (such
            as a single <command>make</command> command), or they are so unique
            that a macro wouldn't make it easier to write the script.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-install-script">
          <title>The <command>%install</command> Script</title>
          <!-- label: inside-install -->
          <indexterm>
            <primary><command>%install</command> script</primary>
          </indexterm>

          <para>
            The environment in which the <command>%install</command> script
            executes is identical to the other scripts.  Like the other scripts,
            the <command>%install</command> script's working directory is set to
            the software's top-level directory.
          </para>
          <para>
            As the name implies, it is this script's responsibility to do
            whatever is necessary to actually install the newly built software.
            In most cases, this means a single <command>make install</command>
            command, or a few commands to copy files and create directories.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-clean-script">
          <title>The <command>%clean</command> Script</title>
          <!-- label: inside-clean -->
          <indexterm>
            <primary><command>%clean</command> script</primary>
          </indexterm>

          <para>
            The <command>%clean</command> script, as the name implies, is used
            to clean up the software's build directory tree.  RPM normally does
            this for you, but in certain cases (most notably in those packages
            that use a build root) you'll need to include a
            <command>%clean</command> script.
          </para>
          <para>
            As usual, the <command>%clean</command> script has the same set of
            environment variables as the other scripts we've covered here.
            Since a <command>%clean</command> script is normally used when the
            package is built in a build root, the <envar>RPM_BUILD_ROOT</envar>
            environment variable is particularly useful.  In many cases, a
            simple

            <screen width="60">
<computeroutput>
rm -rf $RPM_BUILD_ROOT
</computeroutput>
            </screen>
            will suffice.
            <footnote>
              <para>
                Keep in mind that this command in a <command>%clean</command>
                script can wreak havoc if used with a build root of, say,
                <filename>/</filename>.  <xref
                linkend="s3-rpm-b-command-buildroot-warning">
                discusses this in more detail.
              </para>
            </footnote>
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-erase-time-scripts">
        <title>Install/Erase-time Scripts</title>
        <!-- label: inside-install/erase -->
        <indexterm>
          <primary>scripts</primary>
          <secondary>install/erase-time</secondary>
        </indexterm>

        <para>
          The other type of scripts that are present in the spec file are those
          that are only used when the package is either installed or erased.
          There are four scripts, each one meant to be executed at different
          times during the life of a package:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Before installation.
              </para>
            </listitem>

            <listitem>
              <para>
                After installation.
              </para>
            </listitem>

            <listitem>
              <para>
                Before erasure.
              </para>
            </listitem>

            <listitem>
              <para>
                After erasure.
              </para>
            </listitem>
          </itemizedlist>
          <indexterm>
            <primary>scripts</primary>
            <secondary>install/erase-time</secondary>
            <tertiary>environment variables in</tertiary>
          </indexterm>
        </para>

        <para>
          Unlike the build-time scripts, there is little in the way of
          environment variables for these scripts.  The only environment
          variable available is <envar>RPM_INSTALL_PREFIX</envar>, and that is
          only set if the package uses an installation prefix.
        </para>

        <para>
          <indexterm>
            <primary>scripts</primary>
            <secondary>install/erase-time</secondary>
            <tertiary>arguments in</tertiary>
          </indexterm>
          Unlike the build-time scripts, there <emphasis>is</emphasis> an
          argument defined.  The sole argument to these scripts, is a number
          representing the number of instances of the package currently
          installed on the system, <emphasis>after</emphasis> the current
          package has been installed or erased.  Sound tricky?  It really isn't.
          Here's an example:
        </para>
        <para>
          Assume that a package, called <application>blather-1.0</application>, is
          being installed.  No previous versions of <application>blather</application>
          have been installed.  Since the software is being installed, only the
          <command>%pre</command> and <command>%post</command> scripts are
          executed.  The argument passed to these scripts will be 1, since the
          the number of <application>blather</application> packages installed is 1.
          <footnote>
            <para>
              Or it will be 1, once the package is completely installed.
              Remember, the number is based on the number of packages installed
              <emphasis>after</emphasis> the current package's install or erase
              has completed.
            </para>
          </footnote>
        </para>
        <para>
          Continuing our example, a new version of the
          <application>blather</application> package, version 1.3, is now available.
          Clearly it's time to upgrade.  What will the scripts' values be during
          the upgrade?  As <application>blather-1.3</application> is installing, its
          <command>%pre</command> and <command>%post</command> scripts will have
          an argument equal to 2 (1 for version 1.0 already installed, plus 1
          for version 1.3 being installed).  As the final part of the upgrade,
          it's then time to erase <application>blather</application> version 1.0.  As
          the package is being removed, its <command>%preun</command> and
          <command>%postun</command> scripts are executed.  Since there will be
          only one <application>blather</application> package (version 1.3) installed
          after version 1.0 is erased, the argument passed to version 1.0's
          scripts is 1.
        </para>
        <para>
          To finally bring an end to this example, we've decided to erase
          <application>blather</application> 1.3.  We just don't need it anymore.  As
          the package is being erased, its <command>%preun</command> and
          <command>%postun</command> scripts will be executed.  Since there will
          be no <application>blather</application> packages installed once the erase
          completes, the argument passed to the scripts is 0.
        </para>
        <para>
          With all that said, of what possible use would this argument be?
          Well, it has two very interesting properties:

          <orderedlist>
            <listitem>
              <para>
                When the first version of a package is installed, its
                <command>%pre</command> and <command>%post</command> scripts
                will be passed an argument equal to 1.
              </para>
            </listitem>

            <listitem>
              <para>
                When the last version of a package is erased, its
                <command>%preun</command> and <command>%postun</command> scripts
                will be passed an argument equal to 0.
              </para>
            </listitem>
          </orderedlist>
        </para>
        <para>
          Based on these properties, it's trivial to write an install-time
          script that can take certain actions in specific circumstances.
          Usually, the argument is used in the <command>%preun</command> or
          <command>%postun</command> scripts to perform a special task when the
          last instance of a package is being erased.
        </para>
        <para>
          What is normally done during these scripts?  The exact tasks may vary,
          but in general, the tasks are any that need to be performed at these
          points in the package's existence.  One very common task is to run
          <command>ldconfig</command> when shared libraries are installed or
          removed.  But that's not the only use for these scripts.  It's even
          possible to use the scripts to perform tests to ensure the package
          install/erasure should proceed.
        </para>
        <para>
          Since each of these scripts will be executing on whatever system
          installs the package, it's necessary to choose the script's choice of
          tools carefully.  Unless you're sure a given program is going to be
          available on <emphasis>all</emphasis> the systems that could possibly
          install your package, you should not use it in these scripts.
        </para>

        <sect3 id="s3-rpm-inside-pre-script">
          <title>The <command>%pre</command> Script</title>
          <!-- label: inside-pre -->
          <indexterm>
            <primary><command>%pre</command> script</primary>
          </indexterm>

          <para>
            The <command>%pre</command> script executes just before the package
            is to be installed.  It is the rare package that requires anything
            to be done prior to installation; none of the 350 packages that
            comprise &RHL; Linux 4.0 make use of it.
          </para>

          <sect4 id="s4-rpm-inside-post-script">
            <title>The <command>%post</command> Script</title>
            <!-- label: rpm-inside-post -->
            <!-- label: inside-post -->
            <indexterm>
              <primary><command>%post</command> script</primary>
            </indexterm>

            <para>
              The <command>%post</command> script executes after the package has
              been installed.  One of the most popular reasons a
              <command>%post</command> script is needed is to run
              <command>ldconfig</command> to update the list of available shared
              libraries after a new one has been installed.  Of course, other
              functions can be performed in a <command>%post</command> script.
              For example, packages that install shells use the
              <command>%post</command> script to add the shell name to
              <filename>/etc/shells</filename>.
            </para>
            <para>
              If a package uses a <command>%post</command> script to perform
              some function, quite often it will include a
              <command>%postun</command> script that performs the inverse of the
              <command>%post</command> script, after the package has been
              removed.
            </para>
          </sect4>
        </sect3>

        <sect3 id="s3-rpm-inside-preun-script">
          <title>The <command>%preun</command> Script</title>
          <!-- label: inside-preun -->
          <indexterm>
            <primary><command>%preun</command> script</primary>
          </indexterm>

          <para>
            If there's a time when your package needs to have one last look
            around before the user erases it, the place to do it is in the
            <command>%preun</command> script.  Anything that a package needs to
            do immediately prior to RPM taking any action to erase the package,
            can be done here.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-postun-script">
          <title>The <command>%postun</command> Script</title>
          <!-- label: inside-postun -->
          <indexterm>
            <primary><command>%postun</command> script</primary>
          </indexterm>

          <para>
            The <command>%postun</command> script executes after the package has
            been removed.  It is the last chance for a package to clean up after
            itself.  Quite often, <command>%postun</command> scripts are used to
            run <command>ldconfig</command> to remove newly erased shared
            libraries from <filename>ld.so.cache</filename>.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-verifyscript-script">
        <title>
          Verification-Time Script &mdash; The <command>%verifyscript</command>
          Script
        </title>
        <!-- label: inside-verifyscript -->
        <indexterm>
          <primary>scripts</primary>
          <secondary>verification-time</secondary>
        </indexterm>

        <indexterm>
          <primary><command>%verifyscript</command> script</primary>
        </indexterm>

        <para>
          The <command>%verifyscript</command> executes whenever the installed
          package is verified by RPM's verification command.  The contents of
          this script is entirely up to the package builder, but in general the
          script should do whatever is necessary to verify the package's proper
          installation.  Since RPM automatically verifies the existence of a
          package's files, along with other file attributes, the
          <command>%verifyscript</command> should concentrate on different
          aspects of the package's installation.  For example, the script may
          ensure that certain configuration files contain the proper information
          for the package being verified:

          <screen width="60">
<computeroutput>
for n in ash bsh; do
    echo -n "Looking for $n in /etc/shells... "
    if ! grep "^/bin/${n}\$" /etc/shells &gt; /dev/null; then
        echo "missing"
        echo "${n} missing from /etc/shells" &gt;&2
    else
        echo "found"
    fi
done
</computeroutput>
          </screen>
        </para>
        <para>
          In this script, the config file <filename>/etc/shells</filename>, is
          checked to ensure that it has entries for the shells provided by this
          package.
        </para>
        <para>
          It is worth noting that the script sends informational and error
          messages to stdout, and error messages only to stderr.  Normally RPM
          will only display error output from a verification script; the output
          sent to stdout is only displayed when the verification is run in
          verbose mode.

        </para>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-inside-macros">
      <title>Macros: Helpful Shorthand for Package Builders</title>
      <!-- label: rpm-macros -->
      <indexterm>
        <primary>spec file</primary>
        <secondary>macros in</secondary>
      </indexterm>

      <para>
        RPM does not support macros in the sense of ad-hoc sequences of commands
        being defined as a macro and executed by simply referring to the macro
        name.
      </para>
      <para>
        However, there are two parts of RPM's build process that are fairly
        constant from one package to another, and they are the unpacking and
        patching of sources.  Because of this, RPM makes two macros available to
        simplify these tasks:

        <orderedlist>
          <listitem>
            <para>
              The <command>%setup</command> macro, which is used to unpack the
              original sources.
            </para>
          </listitem>

          <listitem>
            <para>
              The <command>%patch</command> macro, which is used to apply
              patches to the original sources.
            </para>
          </listitem>
        </orderedlist>
      </para>

      <para>
        These macros are used exclusively in the <command>%prep</command>
        script; it wouldn't make sense to use them anywhere else.  The use of
        these macros is not mandatory &mdash; It is certainly possible to write
        a <command>%prep</command> script without them.  But in the vast
        majority of cases they make life easier for the package builder.
      </para>

      <sect2 id="s2-rpm-inside-setup-macro">
        <title>The <command>%setup</command> Macro</title>
        <!-- label: inside-setup -->
        <indexterm>
          <primary><command>%setup</command> macro</primary>
        </indexterm>

        <para>
          As we mentioned above, the <command>%setup</command> macro is used to
          unpack the original sources, in preparation for the build.  In its
          simplest form, the macro is used with no options and gets the name of
          the source archive from the <command>source</command> tag specified
          earlier in the spec file.  Let's look at an example.  The
          <application>cdplayer</application> package has the following
          <command>source</command> tag:

          <screen width="60">
<computeroutput>
Source: ftp://ftp.gnomovision.com/pub/cdplayer/cdplayer-1.0.tgz
</computeroutput>
          </screen>
        </para>
        <para>
          and the following <command>%prep</command> script:

          <screen width="60">
<computeroutput>
%prep
%setup
</computeroutput>
          </screen>
        </para>
        <para>
          In this simple case, the <command>%setup</command> macro expands into
          the following commands:

          <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
          </screen>
        </para>
        <para>
          As we can see, the <command>%setup</command> macro starts by changing
          directory into RPM's build area and removing any
          <application>cdplayer</application> build trees from previous builds.  It
          then uses <command>gzip</command> to uncompress the original source
          (whose name was taken from the <command>source</command> tag), and
          pipes the result to <command>tar</command> for unpacking.  The return
          status of the unpacking is tested.  If successful, the macro continues.
        </para>
        <para>
          At this point, the original sources have been unpacked.  The
          <command>%setup</command> macro continues by changing directory into
          <application>cdplayer</application>'s top-level directory.  The two
          <command>cd</command> commands are an artifact of
          <command>%setup</command>'s macro expansion.  Finally,
          <command>%setup</command> makes sure every file in the build tree is
          owned by root and has appropriate permissions set.
        </para>
        <para>
          But that's just the simplest way that <command>%setup</command> can be
          used.  There are a number of other options that can be added to
          accommodate different situations.  Let's look at them.
        </para>

        <sect3 id="s3-rpm-inside-setup-n-option">
          <title>
            <command>-n <replaceable>&lt;name&gt;</replaceable></command>
            &mdash; Set Name of Build Directory
          </title>
          <!-- label: inside-setup-n -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-n</command> option</secondary>
          </indexterm>

          <para>
            In our example above, the <command>%setup</command> macro simply
            uncompressed and unpacked the sources.  In this case, the
            <command>tar</command> file containing the original sources was
            created such that the top-level directory was included in the tar
            file.  The name of the top-level directory was also identical to
            that of the <command>tar</command> file, which was in
            <command><replaceable>&lt;name&gt;</replaceable>-<replaceable>&lt;version&gt;</replaceable></command>
            format.
          </para>
          <para>
            However, this is not always the case.  Quite often, the original
            sources unpack into a directory whose name is different than the
            original <command>tar</command> file.  Since RPM assumes the
            directory will be called
            <command><replaceable>&lt;name&gt;</replaceable>-<replaceable>&lt;version&gt;</replaceable></command>,
            when the directory is called something else, it's necessary to use
            <command>%setup</command>'s <command>-n</command> option.  Here's an
            example:
          </para>
          <para>
            Assume, for a moment, that the <application>cdplayer</application>
            sources, when unpacked, create a top-level directory named
            <application>cd-player</application>.  In this case, our
            <command>%setup</command> line would look like this:

            <screen width="60">
<computeroutput>
%setup -n cd-player
</computeroutput>
            </screen>
          </para>
          <para>
            and the resulting commands would look like this:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cd-player
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cd-player
cd /usr/src/redhat/BUILD/cd-player
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            The results are identical to using <command>%setup</command> with no
            options, except for the fact that <command>%setup</command> now does
            a recursive delete on the directory <application>cd-player</application>
            (instead of <application>cdplayer-1.0</application>), and changes
            directory into <application>cd-player</application> (instead of
            <application>cdplayer-1.0</application>).
          </para>
          <para>
            Note that all subsequent build-time scripts will change directory
            into the directory specified by the <command>-n</command> option.
            This makes <command>-n</command> unsuitable as a means of unpacking
            sources in directories other than the top-level build directory.  In
            the upcoming example on <xref
            linkend="s3-rpm-inside-setup-multi-source">, we'll show a way around
            this restriction.
          </para>
          <para>
            A quick word of warning: If the name specified with the
            <command>-n</command> option doesn't match the name of the directory
            created when the sources are unpacked, the build will stop pretty
            quickly, so it pays to be careful when using this option.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-c-option">
          <title>
            <command>-c</command> &mdash; Create Directory (and change to it)
            Before Unpacking
          </title>
          <!-- label: inside-setup-c -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-c</command> option</secondary>
          </indexterm>

          <para>
            How many times have you grabbed a <command>tar</command> file and
            unpacked it, only to find that it splattered files all over your
            current directory?  Sometimes source archives are created without a
            top-level directory.
          </para>
          <para>
            As you can see from the examples so far, <command>%setup</command>
            expects the archive to create its own top-level directory.  If this
            isn't the case, you'll need to use the <command>-c</command> option.
          </para>
          <para>
            This option simply creates the directory and changes directory into
            it before unpacking the sources.  Here's what it looks like:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
mkdir -p cdplayer-1.0
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            The only changes from using <command>%setup</command> with no
            options, are the <command>mkdir</command> and <command>cd</command>
            commands, prior to the commands that unpack the sources.  Note that
            you can use the <command>-n</command> option along with
            <command>-c</command>, so something like <command>%setup -c -n
            blather</command> works as expected.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-d-option">
          <title>
            <command>-D</command> &mdash; Do Not Delete Directory Before
            Unpacking Sources
          </title>
          <!-- label: inside-setup-D -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-D</command> option</secondary>
          </indexterm>

          <para>
            The <command>-D</command> option keeps the <command>%setup</command>
            macro from deleting the software's top-level directory.  This option
            is handy when the sources being unpacked are to be added to an
            already-existing directory tree.  This would be the case when more
            than one <command>%setup</command> macro is used.  Here's what
            <command>%setup</command> does when the <command>-D</command> option
            is employed:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            As advertised, the <command>rm</command> prior to the
            <command>tar</command> command is gone.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-t-option">
          <title>
            <command>-T</command> &mdash; Do Not Perform Default Archive
            Unpacking
          </title>
          <!-- label: inside-setup-T -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-T</command> option</secondary>
          </indexterm>

          <para>
            The <command>-T</command> option disables
            <command>%setup</command>'s normal unpacking of the archive file
            specified on the <command>source0</command> line.  Here's what the
            resulting commands look like:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            Doesn't make much sense, does it?  There's a method to this madness.
            We'll see the <command>-T</command> in action in the next section.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-b-option">
          <title>
            <command>-b <replaceable>&lt;n&gt;</replaceable></command> &mdash;
            Unpack The <emphasis>n</emphasis>th Sources Before Changing
            Directory
          </title>
          <!-- label: inside-setup-b -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-b</command> option</secondary>
          </indexterm>

          <para>
            The <command>-b</command> option is used in conjunction with the
            <command>source</command> tag.  Specifically, it is used to identify
            which of the numbered <command>source</command> tags in the spec
            file are to be unpacked.
          </para>
          <para>
            The <command>-b</command> option requires a numeric argument
            matching an existing <command>source</command> tag.  If a numeric
            argument is not provided, the build will fail:

            <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba cdplayer-1.0.spec</command>
* Package: cdplayer
Need arg to %setup -b
Build failed.
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Remembering that the first <command>source</command> tag is
            implicitly numbered 0, let's see what happens when the
            <command>%setup</command> line is changed to <command>%setup -b
            0</command>:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            That's strange.  The sources were unpacked twice.  It doesn't make
            sense, until you realize that this is why there is a
            <command>-T</command> option.  Since <command>-T</command> disables
            the default source file unpacking, and <command>-b</command> selects
            a particular source file to be unpacked, the two are meant to go
            together, like this:

            <screen width="60">
<computeroutput>
%setup -T -b 0
</computeroutput>
            </screen>
          </para>
          <para>
            Looking at the resulting commands, we find:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            That's more like it!  Let's go on to the next option.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-a-option">
          <title>
            <command>-a <replaceable>&lt;n&gt;</replaceable></command> &mdash;
            Unpack The <emphasis>n</emphasis>th Sources After Changing Directory
          </title>
          <!-- label: inside-setup-a -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary><command>-a</command> option</secondary>
          </indexterm>

          <para>
            The <command>-a</command> option works similarly to the
            <command>-b</command> option, except that the sources are unpacked
            <emphasis>after</emphasis> changing directory into the top-level
            build directory.  Like the <command>-b</command> option,
            <command>-a</command> requires <command>-T</command> in order to
            prevent two sets of unpacking commands.  Here are the commands that
            a <command>%setup -T -a 0</command> line would produce:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            Note that there is no <command>mkdir</command> command to create the
            top-level directory prior to issuing a <command>cd</command> into
            it.  In our example, adding the <command>-c</command> option will
            make things right:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
mkdir -p cdplayer-1.0
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            The result is the proper sequence of commands for unpacking a
            <command>tar</command> file with no top-level directory.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-setup-multi-source">
          <title>
            Using <command>%setup</command> in a Multi-source Spec File
          </title>
          <!-- label: multi-source-spec -->
          <indexterm>
            <primary><command>%setup</command> macro</primary>
            <secondary>use in multi-source spec files</secondary>
          </indexterm>

          <para>
            If all these interrelated options seem like overkill for unpacking a
            single source file, you're right.  The real reason for the various
            options is to make it easier to combine several separate source
            archives into a single, build-able entity.  Let's see how they work
            in that type of environment.
          </para>
          <para>
            For the purposes of this example, our spec file will have the
            following three <command>source</command> tags:
            <footnote>
              <para>
                Yes, the <command>source</command> tags should include a URL
                pointing to the sources.
              </para>
            </footnote>

            <screen width="60">
<computeroutput>
source: source-zero.tar.gz
source1: source-one.tar.gz
source2: source-two.tar.gz
</computeroutput>
            </screen>
          </para>
          <para>
            To unpack the first source is not hard; all that's required is to
            use <command>%setup</command> with no options:

            <screen width="60">
<computeroutput>
%setup
</computeroutput>
            </screen>
          </para>
          <para>
            This produces the following set of commands:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            If <filename>source-zero.tar.gz</filename> didn't include a
            top-level directory, we could have made one by adding the
            <command>-c</command> option:

            <screen width="60">
<computeroutput>
%setup -c
</computeroutput>
            </screen>
          </para>
          <para>
            which would result in:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
mkdir -p cdplayer-1.0
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            Of course, if the top-level directory did not match the package
            name, the <command>-n</command> option could have been added:

            <screen width="60">
<computeroutput>
%setup -n blather
</computeroutput>
            </screen>
          </para>
          <para>
            which results in:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf blather
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd blather
cd /usr/src/redhat/BUILD/blather
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            or

            <screen width="60">
<computeroutput>
%setup -c -n blather
</computeroutput>
            </screen>
          </para>
          <para>
            This results in:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf blather
mkdir -p blather
cd blather
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/blather
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            Now let's add the second source file.  Things get a bit more
            interesting here.  First, we need to identify which
            <command>source</command> tag (and therefore, which source file)
            we're talking about.  So we need to use either the
            <command>-a</command> or <command>-b</command> option, depending on
            the characteristics of the source archive.  For this example, let's
            say that <command>-a</command> is the option we want.  Adding that
            option, plus a "1" to point to the source file specified in the
            <command>source1</command> tag, we have:

            <screen width="60">
<computeroutput>
%setup -a 1
</computeroutput>
            </screen>
          </para>
          <para>
            Since we've already seen that using the <command>-a</command> or
            <command>-b</command> option results in duplicate unpacking, we need
            to disable the default unpacking by adding the <command>-T</command>
            option:

            <screen width="60">
<computeroutput>
%setup -T -a 1
</computeroutput>
            </screen>
          </para>
          <para>
            Next, we need to make sure that the top-level directory isn't
            deleted.  Otherwise, the first source file we just unpacked would be
            gone.  That means we need to include the <command>-D</command>
            option to prevent that from happening.  Adding this final option,
            and including the now complete macro in our <command>%prep</command>
            script, we now have:

            <screen width="60">
<computeroutput>
%setup
%setup -T -D -a 1
</computeroutput>
            </screen>
          </para>
          <para>
            This will result in the following commands:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
cd /usr/src/redhat/BUILD
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-one.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
            </screen>
          </para>
          <para>
            So far, so good.  Let's include the last source file, but with this
            one, we'll say that it needs to be unpacked in a subdirectory of
            <application>cdplayer-1.0</application> called
            <filename>database</filename>.  Can we use <command>%setup</command>
            in this case?
          </para>
          <para>
            We could, if <filename>source-two.tgz</filename> created the
            <filename>database</filename> subdirectory.  If not, then it'll be
            necessary to do it by hand.  For the purposes of our example, let's
            say that <filename>source-two.tgz</filename> wasn't created to
            include the <filename>database</filename> subdirectory, so we'll
            have to do it ourselves.  Here's our <command>%prep</command> script
            now:

            <screen width="60">
<computeroutput>
%setup
%setup -T -D -a 1
mkdir database
cd database
gzip -dc /usr/src/redhat/SOURCES/source-two.tar.gz | tar -xvvf -
</computeroutput>
            </screen>
          </para>
          <para>
            Here's the resulting script:

            <screen width="60">
<computeroutput>
cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-zero.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
cd /usr/src/redhat/BUILD
cd cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/source-one.tar.gz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
mkdir database
cd database
gzip -dc /usr/src/redhat/SOURCES/source-two.tar.gz | tar -xvvf -
</computeroutput>
            </screen>
          </para>
          <para>
            The three commands we added to unpack the last set of sources were
            added to the end of the <command>%prep</command> script.
          </para>
          <para>
            The bottom line to using the <command>%setup</command> macro is that
            you can probably get it to do what you want, but don't be afraid to
            tinker.  And even if <command>%setup</command> can't be used, it's
            easy enough to add the necessary commands to do the work manually.
            Above all, make sure you use the <command>--test</command> option
            when testing your <command>%setup</command> macros, so you can see
            what commands they're translating to.
          </para>
          <para>
            Next, let's look at RPM's second macro, <command>%patch</command>.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-patch-macro">
        <title>The <command>%patch</command> Macro</title>
        <!-- label: inside-patch-macro -->
        <indexterm>
          <primary><command>%patch</command> macro</primary>
        </indexterm>

        <para>
          The <command>%patch</command> macro, as its name implies, is used to
          apply patches to the unpacked sources.  In the following examples, our
          spec file has the following <command>patch</command> tag lines:

          <screen width="60">
<computeroutput>
patch0: patch-zero
patch1: patch-one
patch2: patch-two
</computeroutput>
          </screen>
        </para>
        <para>
          At its simplest, the <command>%patch</command> macro can be invoked
          without any options:

          <screen width="60">
<computeroutput>
%patch
</computeroutput>
          </screen>
        </para>
        <para>
          Here are the resulting commands:

          <screen width="60">
<computeroutput>
echo "Patch #0:"
patch -p0  -s &lt; /usr/src/redhat/SOURCES/patch-zero
</computeroutput>
          </screen>
        </para>
        <para>
          The <command>%patch</command> macro nicely displays a message showing
          that a patch is being applied, then invokes the
          <command>patch</command> command to actually do the dirty work.  There
          are two options to the <command>patch</command> command:

          <orderedlist>
            <listitem>
              <para>
                The <command>-p</command> option, which directs
                <command>patch</command> to remove the specified number of
                slashes (and any intervening directories) from the front of any
                filenames specified in the patch file.  In this case, nothing
                will be removed.
              </para>
            </listitem>

            <listitem>
              <para>
                The <command>-s</command> option, which directs
                <command>patch</command> to apply the patch without displaying
                any informational messages.  Only errors from
                <command>patch</command> will be displayed.
              </para>
            </listitem>
          </orderedlist>
        </para>

        <para>
          How did the <command>%patch</command> macro know which patch to apply?
          Keep in mind that, like the <command>source</command> tag lines, every
          <command>patch</command> tag is numbered, starting at zero.  The
          <command>%patch</command> macro, by default, applies the patch file
          named on the <command>patch</command> (or <command>patch0</command>)
          tag line.
        </para>

        <sect3 id="s3-rpm-inside-which-patch-tag">
          <title>Specifying Which <command>patch</command> Tag to Use</title>
          <!-- label: inside-patch-P -->
          <indexterm>
            <primary><command>%patch</command> macro</primary>
            <secondary><command>-P</command> option</secondary>
          </indexterm>

          <para>
            The <command>%patch</command> macro actually has two different ways
            to specify the <command>patch</command> tag line it is to use.  The
            first method is to simply append the number of the desired
            <command>patch</command> tag to the end of the
            <command>%patch</command> macro itself.  For example, in order to
            apply the patch specified on the <command>patch2</command> tag line,
            the following <command>%patch</command> macro could be used:

            <screen width="60">
<computeroutput>
%patch2
</computeroutput>
            </screen>
          </para>
          <para>
            The other approach is to use the <command>-P</command> option.  This
            option is followed by the number of the <command>patch</command> tag
            line desired.  Therefore, this line is identical in function to the
            previous one:

            <screen width="60">
<computeroutput>
%patch -P 2
</computeroutput>
            </screen>
          </para>
          <para>
            Note that the <command>-P</command> option will
            <emphasis>not</emphasis> apply the file specified on the
            <command>patch0</command> line, by default.  Therefore, if you
            choose to use the <command>-P</command> option to specify patch
            numbers, you'll need to use the following format when applying patch
            zero:

            <screen width="60">
<computeroutput>
%patch -P 0
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-patch-p-option">
          <title>
            <command>-p <replaceable>&lt;#&gt;</replaceable></command> &mdash;
            Strip <command><replaceable>&lt;#&gt;</replaceable></command>
            leading slashes and directories from patch filenames
          </title>
          <!-- label: inside-patch-p -->
          <indexterm>
            <primary><command>%patch</command> macro</primary>
            <secondary><command>-p</command> option</secondary>
          </indexterm>

          <para>
            The <command>-p</command> (Note the <emphasis>lowercase</emphasis>
            "p"!) option is sent directly to the <command>patch</command>
            command.  It is followed by a number, which specifies the number of
            leading slashes (and the directories in between) to strip from any
            filenames present in the patch file.  For more information on this
            option, please consult the <command>patch</command> man page.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-b-option">
          <title>
            <command>-b <replaceable>&lt;name&gt;</replaceable></command>
            &mdash; Set the backup file extension to
            <command><replaceable>&lt;name&gt;</replaceable></command>
          </title>
          <!-- label: inside-patch-b -->
          <indexterm>
            <primary><command>%patch</command> macro</primary>
            <secondary><command>-b</command> option</secondary>
          </indexterm>

          <para>
            When the <command>patch</command> command is used to apply a patch,
            unmodified copies of the files patched are renamed to end with the
            extension <filename>.orig</filename>.  The <command>-b</command>
            option is used to change the extension used by
            <command>patch</command>.  This is normally done when multiple
            patches are to be applied to a given file.  By doing this, copies of
            the file as it existed prior to each patch, are readily available.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-e-option">
          <title><command>-E</command> &mdash; Remove Empty Output Files</title>
          <!-- label: inside-patch-E -->
          <indexterm>
            <primary><command>%patch</command> macro</primary>
            <secondary><command>-E</command> option</secondary>
          </indexterm>

          <para>
            The <command>-E</command> option is passed directly to the
            <command>patch</command> program.  When <command>patch</command> is
            run with the <command>-E</command> option, any output files that are
            empty after the patches have been applied, are removed.
          </para>
          <para>
            Now let's take <command>%patch</command> on a test-drive, and put it
            through its paces.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-patch-rw">
          <title>
            An example of the <command>%patch</command> Macro in Action
          </title>
          <indexterm>
            <primary><command>%patch</command> macro</primary>
            <secondary>example of</secondary>
          </indexterm>

          <para>
            Using the example <command>patch</command> tag lines we've used
            throughout this section, let's put together an example and look at
            the resulting commands.  In our example, the first patch to be
            applied needs to have the root directory stripped.  Its
            <command>%patch</command> macro will look like this:

            <screen width="60">
<computeroutput>
%patch -p1
</computeroutput>
            </screen>
          </para>
          <para>
            The next patch is to be applied to files in the software's
            <filename>lib</filename> subdirectory, so we'll need to add a
            <command>cd</command> command to get us there.  We'll also need to
            strip an additional directory:

            <screen width="60">
<computeroutput>
cd lib
%patch -P 1 -p2
</computeroutput>
            </screen>
          </para>
          <para>
            Finally, the last patch is to be applied from the software's
            top-level directory, so we need to <command>cd</command> back up a
            level.  In addition, this patch modifies some files that were also
            patched the first time, so we'll need to change the backup file
            extension:

            <screen width="60">
<computeroutput>
cd ..
%patch -P 2 -p1 -b .last-patch
</computeroutput>
            </screen>
          </para>
          <para>
            Here's what the <command>%prep</command> script (minus any
            <command>%setup</command> macros) looks like:

            <screen width="60">
<computeroutput>
%patch -p1
cd lib
%patch -P 1 -p2
cd ..
%patch -P 2 -p1 -b .last-patch
</computeroutput>
            </screen>
          </para>
          <para>
            And here's what the macros expand to:

            <screen width="60">
<computeroutput>
echo "Patch #0:"
patch -p1  -s &lt; /usr/src/redhat/SOURCES/patch-zero
cd lib
echo "Patch #1:"
patch -p2  -s &lt; /usr/src/redhat/SOURCES/patch-one
cd ..
echo "Patch #2:"
patch -p1 -b .last-patch -s &lt; /usr/src/redhat/SOURCES/patch-two
</computeroutput>
            </screen>
          </para>
          <para>
            No surprises here.  Note that the <command>%setup</command> macro
            leaves the current working directory set to the software's top-level
            directory, so our <command>cd</command> commands with their relative
            paths will do the right thing.  Of course, we have environment
            variables available that could be used here, too.
          </para>

          <sect4 id="s4-rpm-inside-patch-compressed">
            <title>Compressed Patch Files</title>
            <indexterm>
              <primary><command>%patch</command> macro</primary>
              <secondary>compressed patches</secondary>
            </indexterm>

            <para>
              If a patch file is compressed with <command>gzip</command>, RPM
              will automatically decompress it before applying the patch.
              Here's a compressed patch file as specified in the spec file:

              <screen width="60">
<computeroutput>
Patch: bother-3.5-hack.patch.gz
</computeroutput>
              </screen>
            </para>
            <para>
              This is part of the script RPM will execute when the
              <command>%prep</command> section is executed:

              <screen width="60">
<computeroutput>
echo Executing: %prep
&hellip;
echo "Patch #0:"
gzip -dc /usr/src/redhat/SOURCES/bother-3.5-hack.patch.gz | patch -p1  -s
&hellip;
</computeroutput>
              </screen>
            </para>
            <para>
              First, the patch file is decompressed using
              <command>gzip</command>.  The output from <command>gzip</command>
              is then piped into <command>patch</command>.
            </para>
            <para>
              That's about it for RPM's macros.  Next, let's take a look at the
              <command>%files</command> list.
            </para>
          </sect4>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-inside-files-list">
      <title>The <command>%files</command> List</title>
      <!-- label: rpm-files-list -->
      <!-- label: inside-files -->
      <indexterm>
        <primary>spec file</primary>
        <secondary><command>%files</command> list in</secondary>
      </indexterm>

      <para>
        The <command>%files</command> list indicates to RPM which files on the
        build system are to be packaged.  The list consists of one file per
        line.  The file may have one or more directives preceding it.  These
        directives give RPM additional information about the file and are
        discussed more fully below.
      </para>
      <para>
        Normally, each file includes its full path.  The path performs two
        functions.  First, it specifies the file's location on the build system.
        Second, it denotes where the file should be placed when the package is
        to be installed.
        <footnote>
          <para>
            This is not entirely the case when a relocatable package is being
            built.  For more information on relocatable packages, see <xref
            linkend="ch-rpm-reloc">.
          </para>
        </footnote>
      </para>
      <para>
        For packages that create directories containing hundreds of files, it
        can be quite cumbersome creating a list that contains every file.  To
        make this situation a bit easier, if the <command>%files</command> list
        contains a path to a directory, RPM will automatically package every
        file in that directory, as well as every file in each subdirectory.
        Shell-style globbing can also be used in the <command>%files</command>
        list.
      </para>
    </sect1>

    <sect1 id="s1-rpm-inside-files-list-directives">
      <title>Directives For the <command>%files</command> list</title>
      <indexterm>
        <primary>spec file</primary>
        <secondary><command>%files</command> list directives</secondary>
      </indexterm>

      <para>
        The <command>%files</command> list may contain a number of different
        directives.  They are used to:

        <itemizedlist mark="bullet">
          <listitem>
            <para>
              Identify documentation and configuration files.
            </para>
          </listitem>

          <listitem>
            <para>
              Ensure that a file has the correct permissions and ownership set.
            </para>
          </listitem>

          <listitem>
            <para>
              Control which aspects of a file are to be checked during package
              verification.
            </para>
          </listitem>

          <listitem>
            <para>
              Eliminate some of the tedium in creating the
              <command>%files</command> list.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        In the <command>%files</command> list, one or more directives may be
        placed on a line, separated by spaces, before one or more filenames.
        Therefore, if <command>%foo</command> and <command>%bar</command> are
        two <command>%files</command> list directives, they may be applied to a
        file <filename>baz</filename> in the following manner:

        <screen width="60">
<computeroutput>
%foo %bar baz
</computeroutput>
        </screen>
      </para>
      <para>
        Now it's time to take a look at the directives that inhabit the
        <command>%files</command> list.
      </para>

      <sect2 id="s2-rpm-inside-flist-file-directives">
        <title>File-related Directives</title>

        <para>
          RPM processes files differently according to their type.  However, RPM
          does not have a method of automatically determining file types.
          Therefore, it is up to the package builder to appropriately mark files
          in the <command>%files</command> list.  This is done using one of the
          directives below.
        </para>
        <para>
          Keep in mind that not every file will need to be marked.  As you read
          the following sections, you'll see that directives are only used in
          special circumstances.  In most packages, the majority of files in the
          <command>%files</command> list will not need to be marked.
        </para>

        <sect3 id="s3-rpm-inside-flist-doc-directive">
          <title>The <command>%doc</command> Directive</title>
          <!-- label: rpm-macros-doc -->
          <!-- label: inside-doc -->
          <indexterm>
            <primary><command>%doc</command> directive</primary>
          </indexterm>

          <para>
            The <command>%doc</command> directive flags the filename(s) that
            follow, as being documentation.  RPM keeps track of documentation
            files in its database, so that a user can easily find information
            about an installed package.  In addition, RPM can create a
            package-specific documentation directory during installation and
            copy documentation into it.  Whether or not this additional step is
            taken, is dependent on how a file is specified.  Here is an example:

            <screen width="60">
<computeroutput>
%doc README
%doc /usr/local/foonly/README
</computeroutput>
            </screen>
          </para>
          <para>
            The file <filename>README</filename> exists in the software's
            top-level directory during the build, and is included in the package
            file.  When the package is installed, RPM creates a directory in the
            documentation directory named the same as the package (ie,
            <filename><replaceable>&lt;software&gt;</replaceable>-<replaceable>&lt;version&gt;</replaceable>-<replaceable>&lt;release&gt;</replaceable></filename>),
            and copies the <filename>README</filename> file there.  The newly
            created directory and the <filename>README</filename> file are
            marked in the RPM database as being documentation.  The default
            documentation directory is <filename>/usr/doc</filename>, and can be
            changed by setting the <command>defaultdocdir</command>
            <filename>rpmrc</filename> file entry.  For more information on
            <filename>rpmrc</filename> files, please see <xref
            linkend="ch-rpmrc-file">.
          </para>
          <para>
            The file <filename>/usr/local/foonly/README</filename> was installed
            into that directory during the build and is included in the package
            file.  When the package is installed, the
            <filename>README</filename> file is copied into
            <filename>/usr/local/foonly</filename> and marked in the RPM
            database as being documentation.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-flist-config-directive">
          <title>The <command>%config</command> Directive</title>
          <!-- label: inside-config -->
          <indexterm>
            <primary><command>%config</command> directive</primary>
          </indexterm>

          <para>
            The <command>%config</command> directive is used to flag the
            specified file as being a configuration file.  RPM performs
            additional processing for config files when packages are erased, and
            during installations and upgrades.  This is due to the nature of
            config files: They are often changed by the system administrator,
            and those changes should not be lost.
          </para>
          <para>
            There is a restriction to the <command>%config</command> directive,
            and that restriction is that no more than one filename may follow
            the <command>%config</command>.  This means that the following
            example is the only allowable way to specify config files:

            <screen width="60">
<computeroutput>
%config /etc/foonly
</computeroutput>
            </screen>
          </para>
          <para>
            Note that the full path to the file, as it is installed at build
            time, is required.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-flist-attr-directive">
          <title>The <command>%attr</command> Directive</title>
          <!-- label: inside-attr -->
          <indexterm>
            <primary><command>%attr</command> directive</primary>
          </indexterm>

          <para>
            The <command>%attr</command> directive permits finer control over
            three key file attributes:

            <orderedlist>
              <listitem>
                <para>
                  The file's permissions, or "mode".
                </para>
              </listitem>

              <listitem>
                <para>
                  The file's user ID.
                </para>
              </listitem>

              <listitem>
                <para>
                  The file's group ID.
                </para>
              </listitem>
            </orderedlist>
          </para>

          <para>
            The <command>%attr</command> directive has the following format:

            <screen width="60">
<computeroutput>
%attr(<replaceable>&lt;mode&gt;</replaceable>, <replaceable>&lt;user&gt;</replaceable>, <replaceable>&lt;group&gt;</replaceable>) <replaceable>file</replaceable>
</computeroutput>
            </screen>
          </para>
          <para>
            The mode is specified in the traditional numeric format, while the
            user and group are specified as a string, such as
            "<command>root</command>".  Here's a sample <command>%attr</command>
            directive:

            <screen width="60">
<computeroutput>
%attr(755, root, root) foo.bar
</computeroutput>
            </screen>
          </para>
          <para>
            This would set <filename>foo.bar</filename>'s permissions to 755.
            The file would be owned by user root, group root.  If a particular
            attribute does not need to be specified (usually because the file is
            installed with that attribute set properly), then that attribute may
            be replaced with a dash:

            <screen width="60">
<computeroutput>
%attr(755, -, root) foo.bar
</computeroutput>
            </screen>
          </para>
          <para>
            The main reason to use the <command>%attr</command> directive is to
            permit users without root access to build packages.  The techniques
            for doing this (and a more in-depth discussion of the
            <command>%attr</command> directive) can be found in <xref
            linkend="ch-rpm-anywhere">.
          </para>
        </sect3>

	<sect3 id="s3-rpm-inside-flist-defattr-directive">
	  <title>The <command>%defattr</command></title>
	  <!-- label: inside-defattr -->
	  <indexterm>
	    <primary><command>%defattr</command> Directive</primary>
	  </indexterm>
	  
	  <para>
	    The <command>%defattr</command> directive allows setting
	    of default attributes for files and directives. The
	    <command>%defattr</command> has a similar format to the
	    <command>%attr</command> directive:

            <orderedlist>
              <listitem>
                <para>
                  The default permissions, or "mode" for files.
                </para>
              </listitem>

	      <listitem>
		<para>
		  The default user id.
		</para>
	      </listitem>

	      <listitem>
		<para>
		  The default group id.
		</para>
	      </listitem>

	      <listitem>
		<para>
		  The default permissions, or "mode" for directories.
		</para>
	      </listitem>
	    </orderedlist>
	  </para>

	    <para>
            The <command>%attr</command> directive has the following
            format:

            <screen width="60">
<computeroutput>
%defattr(<replaceable>&lt;file mode&gt;</replaceable>, <replaceable>&lt;user&gt;</replaceable>, <replaceable>&lt;group&gt;</replaceable>, <replaceable>&lt;dir mode&gt;</replaceable>)
</computeroutput>
            </screen>
	    </para>

	    <para>
	      As with <command>%attr</command> if a particular
	      attribute does not need to be specified (usually because
	      the file is installed with that attribute set properly),
	      then that attribute may be replaced with a dash. In
	      addition the directory mode may be ommited.
	      <command>%defattr</command> tends to be used at the top
	      of <command>%files</command>.
	    </para>
	</sect3>

        <sect3 id="s3-rpm-inside-flist-ghost-directive">
          <title>The <command>%ghost</command> Directive</title>
          <!-- label: inside-ghost -->
          <indexterm>
            <primary><command>%ghost</command> directive</primary>
          </indexterm>

          <para>
            As we mentioned in <xref linkend="s1-rpm-inside-files-list">, if a
            file is specified in the <command>%files</command> list, that file
            will automatically be included in the package.  There are times
            when a file should be owned by the package but not installed - log
            files and state files are good examples of cases you might desire
            this to happen.
          </para>
          <para>
            The way to achieve this, is to use the <command>%ghost</command>
            directive.  By adding this directive to the line containing a file,
            RPM will know about the ghosted file, but will not add it to the
            package. However it still needs to be in the buildroot.  Here's an
            example of <command>%ghost</command> in action.
          </para>
          <para>
            The <application>blather-1.0</application> package logs to
            <filename>/var/log/blather.log</filename> in it's default config.
            In the spec file, the <filename>/var/log/blather.log</filename> 
            file is included in the <command>%files</command> list.  We can
	    see that blather.log belongs to the package, and it is removed
	    when the package is.

            <screen width="60">
<computeroutput>
%install
touch $RPM_BUILD_ROOT%{_localstatedir}/log/blather.log
&hellip;
%files
&hellip;
%ghost %{_localstatedir}/log/blather.log
&hellip;
</computeroutput>
<prompt># </prompt><command>rpm -qf /var/log/blather.log</command>
<computeroutput>
blather-1.0-1
</computeroutput>
<prompt># </prompt><command>rpm -ql blather | grep blather.log</command>
<computeroutput>

</computeroutput>
<prompt># </prompt><command>rpm -e blather &amp;&amp; ls /var/log/blather.log</command>
<computeroutput>
ls: /var/log/blather.log: No such file or directory
</computeroutput>
            </screen>
          </para>
          <para>
            There file touched in the <command>%install</command> stage will
            not be installed to <filename>/var/log/blather.log</filename>
            although it will be added to the rpm database, as we can see from
            querying the file, however it is not visible from a package listing,
            but as it is owned by the package it will be removed when the package
            is removed.  In addition it is possible to use setperms to fix the
            permissions on a <command>%ghost</command> file.
	    <screen width="60">
<prompt># </prompt><command>ls -al /var/log/blather.log</command>
<computeroutput>
-rw-r--r--    1 root     root         3448 Jun 18 17:00 /var/log/blather.log
</computeroutput>
<prompt>#</prompt><command>chmod 666 /var/log/blather.log</command>
<prompt># </prompt><command>ls -al /var/log/blather.log</command>
<computeroutput>
-rw-rw-rw-    1 root     root         3448 Jun 18 17:00 /var/log/blather.log
</computeroutput>
<prompt>#</prompt><command>rpm --setperms blather</command>
<prompt># </prompt><command>ls -al /var/log/blather.log</command>
<computeroutput>
-rw-r--r--    1 root     root         3448 Jun 18 17:00 /var/log/blather.log
</computeroutput>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-flist-verify-directive">
          <title>The <command>%verify</command> Directive</title>
          <!-- label: spec-verify -->
          <!-- label: inside-verify -->
          <indexterm>
            <primary><command>%verify</command> directive</primary>
          </indexterm>

          <para>
            RPM's ability to verify the integrity of the software it has
            installed is impressive.  But sometimes it's a bit
            <emphasis>too</emphasis> impressive.  After all, RPM can verify as
            many as nine different aspects of every file.  The
            <command>%verify</command> directive can control which of these file
            attributes are to be checked when an RPM verification is done.  Here
            are the attributes, along with the names used by the
            <command>%verify</command> directive:

            <orderedlist>
              <listitem>
                <para>
                  Owner (<command>owner</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Group (<command>group</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Mode (<command>mode</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  MD5 Checksum (<command>md5</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Size (<command>size</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Major Number (<command>maj</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Minor Number (<command>min</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Symbolic Link String (<command>symlink</command>)
                </para>
              </listitem>

              <listitem>
                <para>
                  Modification Time (<command>mtime</command>)
                </para>
              </listitem>
            </orderedlist>
          </para>

          <para>
            How is <command>%verify</command> used?  Say, for instance, that a
            package installs device files.  Since the owner of a device will
            change, it doesn't make sense to have RPM verify the device file's
            owner/group and give out a false alarm.  Instead, the following
            <command>%verify</command> directive could be used:

            <screen width="60">
<computeroutput>
%verify(mode md5 size maj min symlink mtime) /dev/ttyS0
</computeroutput>
            </screen>
          </para>
          <para>
            We've left out <command>owner</command> and
            <command>group</command>, since we'd rather RPM not verify those.
            <footnote>
              <para>
                RPM will automatically exclude file attributes from verification
                if it doesn't make sense for the type of file.  In our example,
                getting the MD5 checksum of a device file is an example of such
                a situation.
              </para>
            </footnote>
          </para>
          <para>
            However, if all you want to do is prevent RPM from verifying one or
            two attributes, you can use <command>%verify</command>'s alternate
            syntax:

            <screen width="60">
<computeroutput>
%verify(not owner group) /dev/ttyS0
</computeroutput>
            </screen>
          </para>
          <para>
            This use of <command>%verify</command> produces identical results to
            the previous example.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-inside-flist-directory-directives">
        <title>Directory-related Directives</title>

        <para>
          While the two directives in this section perform different functions,
          each is related to directories in some way.  Let's see what they do:
        </para>

        <sect3 id="s3-rpm-inside-docdir-directive">
          <title>The <command>%docdir</command> Directive</title>
          <!-- label: inside-docdir -->
          <indexterm>
            <primary><command>%docdir</command> directive</primary>
          </indexterm>

          <para>
            The <command>%docdir</command> directive is used to add a directory
            to the list of directories that will contain documentation.  RPM
            includes the directories <filename>/usr/doc</filename>,
            <filename>/usr/info</filename>, and <filename>/usr/man</filename> in
            the <command>%docdir</command> list by default.
          </para>
          <para>
            For example, if the following line is part of the
            <command>%files</command> list:

            <screen width="60">
<computeroutput>
%docdir /usr/blather
</computeroutput>
            </screen>
          </para>
          <para>
            any files in the <command>%files</command> list that RPM packages
            from <filename>/usr/blather</filename> will be included in the
            package as usual, but will also be automatically flagged as
            documentation.  This directive is handy when a package creates its
            own documentation directory and contains a large number of files.
            Let's give it a try by adding the following line to our spec file:

            <screen width="60">
<computeroutput>
%docdir /usr/blather
</computeroutput>
            </screen>
          </para>
          <para>
            Our <command>%files</command> list contains no references to the
            several files the package installs in the
            <filename>/usr/blather</filename> directory.  After building the
            package, looking at the package's file list shows:

            <screen width="60">
<prompt># </prompt><command>rpm -qlp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
&hellip;
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Wait a minute: There's nothing there, not even
            <filename>/usr/blather</filename>!  What happened?
          </para>
          <para>
            The problem is that <command>%docdir</command> only directs RPM to
            mark the specified directory as holding documentation.  It
            <emphasis>doesn't</emphasis> direct RPM to package any files in the
            directory.  To do that, we need to clue RPM in to the fact that
            there are files in the directory that must be packaged.
          </para>
          <para>
            One way to do this is to simply add the files to the
            <command>%files</command> list:

            <screen width="60">
<computeroutput>
%docdir /usr/blather
/usr/blather/INSTALL
</computeroutput>
            </screen>
          </para>
          <para>
            Looking at the package, we see that <filename>INSTALL</filename> was
            packaged:

            <screen width="60">
<prompt># </prompt><command>rpm -qlp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
&hellip;
/usr/blather/INSTALL
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Directing RPM to only show the documentation files, we see that
            <filename>INSTALL</filename> has indeed been marked as
            documentation, even though the <command>%doc</command> directive had
            not been used:

            <screen width="60">
<prompt># </prompt><command>rpm -qdp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
&hellip;
/usr/blather/INSTALL
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            Of course, if you go to the trouble of adding each file to the
            <command>%files</command> list, it wouldn't be that much more work
            to add <command>%doc</command> to each one.  So the way to get the
            most benefit from <command>%docdir</command> is to add another line
            to the <command>%files</command> list:

            <screen width="60">
<computeroutput>
%docdir /usr/blather
/usr/blather
</computeroutput>
            </screen>
          </para>
          <para>
            Since the first line directs RPM to flag any file in
            <filename>/usr/blather</filename> as being documentation, and the
            second line tells RPM to automatically package any files found in
            <filename>/usr/blather</filename>, every single file in there will
            be packaged <emphasis>and</emphasis> marked as documentation:

            <screen width="60">
<prompt># </prompt><command>rpm -qdp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
/usr/blather
/usr/blather/COPYING
/usr/blather/INSTALL
/usr/blather/README
&hellip;
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            The <command>%docdir</command> directive can save quite a bit of
            effort in creating the <command>%files</command> list.  The only
            caveat is that you must be sure the directory will only contain
            files you want marked as documentation.  Keep in mind, also, that
            all subdirectories of the <command>%docdir</command>'ed directory
            will be marked as documentation directories, too.
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-dir-directive">
          <title>The <command>%dir</command> Directive</title>
          <!-- label: inside-dir -->
          <indexterm>
            <primary><command>%dir</command> directive</primary>
          </indexterm>

          <para>
            As we mentioned in <xref linkend="s1-rpm-inside-files-list">, if a
            directory is specified in the <command>%files</command> list, the
            contents of that directory, and the contents of every directory
            under it, will automatically be included in the package.  While this
            feature can be handy (assuming you are <emphasis>sure</emphasis>
            that every file under the directory should be packaged) there are
            times when this could be a problem.
          </para>
          <para>
            The way to get around this, is to use the <command>%dir</command>
            directive.  By adding this directive to the line containing the
            directory, RPM will package only the directory itself, regardless of
            what files are in the directory at the time the package is created.
            Here's an example of <command>%dir</command> in action.
          </para>
          <para>
            The <application>blather-1.0</application> package creates the directory
            <filename>/usr/blather</filename> as part of its build.  It also
            puts several files in that directory.  In the spec file, the
            <filename>/usr/blather</filename> directory is included in the
            <command>%files</command> list:

            <screen width="60">
<computeroutput>
%files
&hellip;
/usr/blather
&hellip;
</computeroutput>
            </screen>
          </para>
          <para>
            There are no other entries in the <command>%files</command> list
            that have <filename>/usr/blather</filename> as part of their path.
            After building the package, we use RPM to look at the files in the
            package:

            <screen width="60">
<prompt># </prompt><command>rpm -qlp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
&hellip;
/usr/blather
/usr/blather/COPYING
/usr/blather/INSTALL
/usr/blather/README
&hellip;
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
          <para>
            The files present in <filename>/usr/blather</filename> at the time
            the package was built were included in the package automatically,
            without entering their names in the <command>%files</command> list.
          </para>
          <para>
            However, after changing the <filename>/usr/blather</filename> line
            in the <command>%files</command> list to:

            <screen width="60">
<computeroutput>
%dir /usr/blather
</computeroutput>
            </screen>
          </para>
          <para>
            and rebuilding the package, a listing of the package's files now
            includes only the <filename>/usr/blather</filename> directory:

            <screen width="60">
<prompt># </prompt><command>rpm -qlp ../RPMS/i386/blather-1.0-1.i386.rpm</command>
<computeroutput>
&hellip;
/usr/blather
&hellip;
</computeroutput>
<prompt>#</prompt>
            </screen>
          </para>
        </sect3>

        <sect3 id="s3-rpm-inside-flist-f-option">
          <title>
            <command>-f <replaceable>&lt;file&gt;</replaceable></command>
            &mdash; Read the <command>%files</command> List From
            <command><replaceable>&lt;file&gt;</replaceable></command>
          </title>
          <indexterm>
            <primary>spec file</primary>
            <secondary><command>%files</command> list in</secondary>
            <tertiary><command>-f</command> option</tertiary>
          </indexterm>

          <para>
            The <command>-f</command> option is used to direct RPM to read the
            <command>%files</command> list from the named file.  Like the
            <command>%files</command> list in a spec file, the file named using
            the <command>-f</command> option should contain one filename per
            line and also include any of the directives named in this section.
          </para>
          <para>
            Why is it necessary to read filenames from a file rather than have
            the filenames in the spec file?  Here's a possible reason:
          </para>
          <para>
            The filenames' paths may contain a directory name that can only be
            determined at build-time, such as an architecture specification.
            The list of files, minus the variable part of the path, can be
            created, and <command>sed</command> can be used at build-time to
            update the path appropriately.
          </para>
          <para>
            It's not necessary that every filename to be packaged reside in the
            file.  If there are any filenames present in the spec file, they
            will be packaged as well:

            <screen width="60">
<computeroutput>
%files latex -f tetex-latex-skel
/usr/bin/latex
/usr/bin/pslatex
&hellip;
</computeroutput>
            </screen>
          </para>
          <para>
            Here, the filenames present in the file
            <filename>tetex-latex-skel</filename> would be packaged, followed by
            every filename following the <command>%files</command> line.
          </para>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-inside-package-directive">
      <title>The Lone Directive: <command>%package</command></title>
      <!-- label: inside-package -->
      <indexterm>
        <primary><command>%package</command> directive</primary>
      </indexterm>

      <para>
        While every directive we've seen so far is used in the
        <command>%files</command> list, the <command>%package</command>
        directive is different.  It is used to permit the creation of more than
        one package per spec file and can appear at any point in the spec file.
        These additional packages are known as subpackages.  Subpackages are
        named according to the contents of the line containing the
        <command>%package</command> directive.  The format of the package
        directive is:

        <screen width="60">
<computeroutput>
%package: &lt;string&gt;
</computeroutput>
        </screen>
      </para>
      <para>
        The <command>&lt;string&gt;</command> should be a name that describes
        the subpackage.  This string is appended to the base package name to
        produce the subpackage's name.  For example, if a spec file contains a
        <command>name</command> tag value of "<command>foonly</command>", and a
        "<command>%package doc</command>" line, then the subpackage name will be
        <application>foonly-doc</application>.
      </para>

      <sect2 id="s2-rpm-inside-package-n-option">
        <title>
          <command>-n <replaceable>&lt;string&gt;</replaceable></command>
          &mdash; Use
          <command><replaceable>&lt;string&gt;</replaceable></command> As the
          Entire Subpackage Name
        </title>
        <!-- label: inside-package-n -->
        <indexterm>
          <primary><command>%package</command> directive</primary>
          <secondary><command>-n</command> option</secondary>
        </indexterm>

        <para>
          As we mentioned above, the name of a subpackage normally includes the
          main package name.  When the <command>-n</command> option is added to
          the <command>%package</command> directive, it directs RPM to use the
          name specified on the <command>%package</command> line as the entire
          package name.  In the example above, the following
          <command>%package</command> line would create a subpackage named
          <application>foonly-doc</application>:

          <screen width="60">
<computeroutput>
%package doc
</computeroutput>
          </screen>
        </para>
        <para>
          The following <command>%package</command> line would create a
          subpackage named <application>doc</application>:

          <screen width="60">
<computeroutput>
%package -n doc
</computeroutput>
          </screen>
        </para>
        <para>
          The <command>%package</command> directive plays another role in
          subpackage building.  That role is to act as a place to collect tags
          that are specific to a given subpackage.  Any tag placed after a
          <command>%package</command> directive will only apply to that
          subpackage.
        </para>
        <para>
          Finally, the name string specified by the <command>%package</command>
          directive is also used to denote which parts of the spec file are a
          part of that subpackage. This is done by including the string (along
          with the <command>-n</command> option, if present on the
          <command>%package</command> line) on the starting line of the section
          that is to be subpackage-specific.  Here's an example:

          <screen width="60">
<computeroutput>
&hellip;
%package -n bar
&hellip;
%post -n bar
&hellip;
</computeroutput>
          </screen>
        </para>
        <para>
          In this heavily edited spec file segment, a subpackage called
          <application>bar</application> has been defined.  Later in the file is a
          post-install script.  Because it has subpackage
          <application>bar</application>'s name on the <command>%post</command> line,
          the post-install script will be part of the <application>bar</application>
          subpackage only.
        </para>
        <para>
          For more information on building subpackages, please see <xref
          linkend="ch-rpm-subpack">.
        </para>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-inside-conditionals">
      <title>Conditionals</title>
      <indexterm>
        <primary>spec file</primary>
        <secondary>conditionals in</secondary>
      </indexterm>

      <para>
        While the "exclude" and "exclusive" tags
        (<command>excludearch</command>, <command>exclusivearch</command>,
        <command>excludeos</command>, and <command>exclusiveos</command>)
        provide some control over whether a package will be built on a given
        architecture and/or operating system, that control is still rather
        coarse.
      </para>
      <para>
        For example, what should be done if a package will build under multiple
        architectures, but requires slightly different <command>%build</command>
        scripts?  Or what if a package requires a certain set of files under one
        operating system, and an entirely different set under another operating
        system?  The architecture and operating system-specific tags we've
        discussed earlier in the chapter do nothing to help in such situations.
        What can be done?
      </para>
      <para>
        One approach would be to simply create different spec files for each
        architecture or operating system.  While it would certainly work, this
        approach has some problems:

        <itemizedlist mark="bullet">
          <listitem>
            <para>
              More work.  The existence of multiple spec files for a given
              package means that the effort required to make any changes to the
              package is multiplied by however many different spec files there
              are.
            </para>
          </listitem>

          <listitem>
            <para>
              More chance for mistakes.  If any work needs to be done to the
              spec files, the fact they are separate means it is that much
              easier to forget to make the necessary changes to each one.  There
              is also the chance of introducing mistakes each time changes are
              made.
            </para>
          </listitem>
        </itemizedlist>
      </para>

      <para>
        The other approach is to somehow permit the conditional inclusion of
        architecture- or operating system-specific sections of the spec file.
        Fortunately, the RPM designers chose this approach, and it makes
        multi-platform package building easier and less prone to mistakes.
      </para>
      <para>
        We discuss multi-platform package building in depth in <xref
        linkend="ch-rpm-multi">.  For now, let's take a quick look at RPM's
        conditionals.
      </para>

      <sect2 id="s2-rpm-inside-ifarch-conditional">
        <title>The <command>%ifarch</command> Conditional</title>
        <!-- label: inside-ifarch -->
        <indexterm>
          <primary><command>%ifarch</command> conditional</primary>
        </indexterm>

        <para>
          The <command>%ifarch</command> conditional is used to begin a section
          of the spec file that is architecture-specific.  It is followed by one
          or more architecture specifiers, each separated by commas or
          whitespace.  Here is an example:

          <screen width="60">
<computeroutput>
%ifarch i386 sparc
</computeroutput>
          </screen>
        </para>
        <para>
          The contents of the spec file following this line would be processed
          only by Intel x86 or Sun SPARC-based systems.  However, if only this
          line were placed in a spec file, this is what would happen if a build
          was attempted:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba cdplayer-1.0.spec</command>
<computeroutput>
Unclosed %if
Build failed.
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          The problem that surfaced here is that any conditional must be
          "closed" by using either <command>%else</command> or
          <command>%endif</command>.  We'll be covering them a bit later in the
          chapter.
        </para>
      </sect2>

      <sect2 id="s2-rpm-inside-ifnarch-conditional">
        <title>The <command>%ifnarch</command> Conditional</title>
        <!-- label: inside-ifnarch -->
        <indexterm>
          <primary><command>%ifnarch</command> conditional</primary>
        </indexterm>

        <para>
          The <command>%ifnarch</command> conditional is used in a similar
          fashion to <command>%ifarch</command>, except that the logic is
          reversed.  If a spec file contains a conditional block starting with
          <command>%ifarch alpha</command>, that block would be processed only
          if the build was being done on a Digital Alpha/AXP-based system.
          However, if the conditional block started with <command>%ifnarch
          alpha</command>, then that block would be processed only if the build
          were <emphasis>not</emphasis> being done on an Alpha.
        </para>
        <para>
          Like <command>%ifarch</command>, <command>%ifnarch</command> can be
          followed by one or more architectures and must be closed by a
          <command>%else</command> or <command>%endif</command>.
        </para>
      </sect2>

<sect2 id="s2-rpm-inside-ifos-conditional">
        <title>The <command>%ifos</command> Conditional</title>
        <!-- label: inside-ifos -->
        <indexterm>
          <primary><command>%ifos</command> conditional</primary>
        </indexterm>

        <para>
          The <command>%ifos</command> conditional is used to control RPM's spec
          file processing based on the build system's operating system.  It is
          followed by one or more operating system names.  A conditional block
          started with <command>%ifos</command> must be closed by a
          <command>%else</command> or <command>%endif</command>.  Here's an
          example:

          <screen width="60">
<computeroutput>
%ifos linux
</computeroutput>
          </screen>
        </para>
        <para>
          The contents of the spec file following this line would be processed
          only if the build was done on a linux system.
        </para>
      </sect2>

      <sect2 id="s2-rpm-inside-ifnos-conditional">
        <title>The <command>%ifnos</command> Conditional</title>
        <!-- label: inside-ifnos -->
        <indexterm>
          <primary><command>%ifnos</command> conditional</primary>
        </indexterm>

        <para>
          The <command>%ifnos</command> conditional is the logical complement to
          <command>%ifos</command>: that is, if a conditional starting with the
          line <command>%ifnos irix</command> is present in a spec file, then
          the file contents after the <command>%ifnos</command> will not be
          processed if the build system is running Irix.  As always, a
          conditional block starting with <command>%ifnos</command> must be
          closed by a <command>%else</command> or <command>%endif</command>.
        </para>
      </sect2>

      <sect2 id="s2-rpm-inside-else-conditional">
        <title>The <command>%else</command> Conditional</title>
        <!-- label: inside-else -->
        <indexterm>
          <primary><command>%else</command> conditional</primary>
        </indexterm>

        <para>
          The <command>%else</command> conditional is placed between a
          <command>%if</command> conditional of some persuasion, and a
          <command>%endif</command>.  It is used to create two blocks of spec
          file statements, only one of which will be used in any given
          case. Here's an example:

          <screen width="60">
<computeroutput>
%ifarch alpha
make RPM_OPT_FLAGS="$RPM_OPT_FLAGS -I ."
%else
make RPM_OPT_FLAGS="$RPM_OPT_FLAGS"
%endif
</computeroutput>
          </screen>
        </para>
        <para>
          When a build is performed on a Digital Alpha/AXP, some additional
          flags are added to the <command>make</command> command.  On all other
          systems, these flags are not added.
        </para>
      </sect2>

      <sect2 id="s2-rpm-inside-endif-conditional">
        <title>The <command>%endif</command> Conditional</title>
        <!-- label: inside-endif -->
        <indexterm>
          <primary><command>%endif</command> conditional</primary>
        </indexterm>

        <para>
          A <command>%endif</command> is used to end a conditional block of spec
          file statements.  It can follow one of the <command>%if</command>
          conditionals, or the <command>%else</command>.  The
          <command>%endif</command> is always needed after a conditional,
          otherwise the build will fail.  Here's short conditional block, ending
          with a <command>%endif</command>:

          <screen width="60">
<computeroutput>
%ifarch i386
make INTELFLAG=-DINTEL
%endif
</computeroutput>
          </screen>
        </para>
        <para>
          In this example, we see the conditional block started with a
          <command>%ifarch</command> and ended with a
          <command>%endif</command>.
        </para>
        <para>
          Now that we have some more in-depth knowledge of the spec file, let's
          take a look at some of RPM's additional features.  In the next
          chapter, we'll explore how to add dependency information to a package.
        </para>
      </sect2>
    </sect1>
  </chapter>
