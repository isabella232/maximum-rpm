<chapter id="ch-rpm-b-command">
<title><command>rpm -b</command> Command Reference</title>
<!-- label: rpm-b-command -->

<indexterm>
<primary>rpm -b@<command>rpm -b</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<table id="tb-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
{|l|l|c|}

\multicolumn{3}{|l|}{\LARGE{<command>rpm -b</command>\small{&lt;stage&gt;}
{<emphasis>options</emphasis> file1.spec &hellip;\ fileN.spec}}}


\multicolumn{2}{|c|}{&lt;stage&gt;} & Page


<command>p</command> & Execute <command>\%prep</command> & <xref linkend="build-bp">

<command>c</command> & Execute <command>\%prep</command>, <command>\%build</command> &
<xref linkend="build-bc"> 

<command>i</command> & Execute <command>\%prep</command>, <command>\%build</command>, 
<command>\%install</command> & <xref linkend="build-bi">

<command>b</command> & Execute <command>\%prep</command>, <command>\%build</command>,
<command>\%install</command>.  Package (bin) & <xref linkend="build-bb">

<command>a</command> & Execute <command>\%prep</command>, <command>\%build</command>,
<command>\%install</command>.  Package (bin, src) & <xref linkend="build-ba">

<command>l</command> & Check <command>\%files</command> list & <xref linkend="build-bl">



\multicolumn{3}{|c|}{Parameters}


file1.spec &hellip;\ fileN.spec &
\multicolumn{2}{|l|}{One or more <tt?>.spec</tt?> files}



\multicolumn{2}{|c|}{Build---specific Options} & Page


<command>--short-circuit</command> & Force build to start at particular stage
(<command>-bc</command>, <command>-bi</command> only) & <xref linkend="build--short-circuit">

<command>--test</command> & Create, save build scripts for review &
<xref linkend="build--test">

<command>--clean</command> & Clean up after build &
<xref linkend="build--clean">

<command>--sign</command> & Add a digital signature to the package &
<xref linkend="build--sign">

<command>--buildroot <emphasis>&lt;root&gt;</command></emphasis> & Execute <command>\%install</command> using
<command><emphasis>&lt;root&gt;</command></emphasis> as the root & <xref linkend="build--buildroot">

<command>--buildarch <emphasis>&lt;arch&gt;</command></emphasis> & Perform build for the
<command><emphasis>&lt;arch&gt;</command></emphasis> architecture & <xref linkend="build--buildarch">

<command>--buildos <emphasis>&lt;os&gt;</command></emphasis> & Perform build for the
<command><emphasis>&lt;os&gt;</command></emphasis> operating system & <xref linkend="build--buildos">

<command>--timecheck <emphasis>&lt;secs&gt;</command></emphasis> &  Print a warning if files are over
<command><emphasis>&lt;secs&gt;</command></emphasis> old & <xref linkend="build--timecheck">



\multicolumn{2}{|c|}{General Options} & Page


<command>-vv</command> & Display debugging information & <xref linkend="build-vv">

<command>--quiet</command> & Produce as little output as possible &
<xref linkend="build--quiet">

<command>--rcfile <emphasis>&lt;rcfile&gt;</command></emphasis> & Set alternate rpmrc file to
<command><emphasis>&lt;rcfile&gt;</command></emphasis> & <xref linkend="build--rcfile">


</table>
<sect1 id="s1-rpm-b-command-">
<title><command>rpm -b</command> --- What Does it Do?</title>
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!what it does</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

When RPM is invoked with the <command>-b</command> option, the process of building a
package is started.  The rest of the command will determine exactly what is
to be built and how far the build should proceed.  In this chapter, we'll
explore every aspect of <command>rpm -b</command>.

An RPM build command must have two additional pieces of information, over
and above "<command>rpm -b</command>":

<orderedlist>
<listitem>
<para>
The names of one or more spec files representing software to be
packaged.

</para>
</listitem>

<listitem>
<para>
The desired stage at which the build is to stop.

</para>
</listitem>

</orderedlist>
As we discussed in chapter <xref linkend="rpm-basics">, the spec file is one of the
inputs to RPM's build process.  It contains the information necessary for
RPM to perform the build and package the software.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

There are a number of stages that RPM goes through during a build.  By
specifying that the build process is to stop at a certain stage, the
package builder can monitor the build's progress, make any changes
necessary, and restart the build.  Let's start by looking at the various
stages that can be specified in a build command.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!what it does|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -bp</command> --- Execute <command>\%prep</command></title>
<!-- label: build-bp -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>p</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The command <command>rpm -bp</command> directs RPM to execute the very first step in
the build process.  In the spec file, this step is labeled
<command>%prep</command>.  Every command in the <command>%prep</command> section will be
executed when the <command>-bp</command> option is used.

Here's a simple <command>%prep</command> section from the spec file we used in
chapter <xref linkend="rpm-build">:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%prep
%setup
</screen>
</figure>
This <command>%prep</command> section consists of a single <command>%setup</command> macro.
When using <command>rpm -bp</command> against this spec file, we can see exactly what
<command>%setup</command> does:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bp cdplayer-1.0.spec</userinput>
* Package: cdplayer
+ umask 022
+ echo Executing: %prep
Executing: %prep
+ cd /usr/src/redhat/BUILD
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz
+ tar -xvvf -
drwxrwxr-x root/users        0 Aug  4 22:30 1996 cdplayer-1.0/
-rw-r--r-- root/users    17982 Nov 10 01:10 1995 cdplayer-1.0/COPYING
-rw-r--r-- root/users      627 Nov 10 01:10 1995 cdplayer-1.0/ChangeLog
&hellip;
-rw-r--r-- root/users     2806 Nov 10 01:10 1995 cdplayer-1.0/volume.c
-rw-r--r-- root/users     1515 Nov 10 01:10 1995 cdplayer-1.0/volume.h
+ [ 0 -ne 0 ]
+ cd cdplayer-1.0
+ cd /usr/src/redhat/BUILD/cdplayer-1.0
+ chown -R root.root .
+ chmod -R a+rX,g-w,o-w .
+ exit 0
# 
</screen>
</figure>
First, RPM confirms that the <tt?>cdplayer</tt?> package is the subject of
this build.  Then it sets the umask and starts executing the
<command>%prep</command> section.  At this point, the <command>%setup</command> macro is
doing its thing.  It changes directory into the build area and removes any
old copies of <tt?>cdplayer</tt?>'s build tree.

Next, <command>%setup</command> unzips the sources and uses <command>tar</command> to create
the build tree.  We've removed the complete listing of files, but be
prepared to see <emphasis>lots</emphasis> of output if the software being packaged is
large.

Finally, <command>%setup</command> changes directory into <tt?>cdplayer</tt?>'s build
tree and changes ownership and file permissions appropriately.  The
<tt?>exit 0</tt?> signifies the end of the <command>%prep</command> section, and
therefore, the end of the <command>%setup</command> macro.  Since we used the
<command>-bp</command> option, RPM stopped at this point.  Let's see what RPM left in
the build area:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>cd /usr/src/redhat/BUILD</userinput>
# <userinput>ls -l</userinput>
total 1
drwxr-xr-x   2 root     root         1024 Aug  4 22:30 cdplayer-1.0
#
</screen>
</figure>
There's the top-level directory.  Changing directory into
<tt?>cdplayer-1.0</tt?>, we find the sources are ready to be built:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>cd cdplayer-1.0</userinput>
# <userinput>ls -lF</userinput>
total 216
-rw-r--r--   1 root     root        17982 Nov 10  1995 COPYING
-rw-r--r--   1 root     root          627 Nov 10  1995 ChangeLog
&hellip;
-rw-r--r--   1 root     root         2806 Nov 10  1995 volume.c
-rw-r--r--   1 root     root         1515 Nov 10  1995 volume.h
# 
</screen>
</figure>
We can see that <command>%setup</command>'s <command>chown</command> and <command>chmod</command>
commands did what they were supposed to --- the files are owned by root,
with permissions set appropriately.

If not stopped by the <command>-bp</command> option, the next step in RPM's build
process would be to build the software.  RPM can also be stopped at the end
of the <command>%build</command> section in the spec file.  This is done by using
the <command>-bc</command> option:

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>p</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -bc</command> --- Execute <command>\%prep</command>, <command>\%build</command></title>
<!-- label: build-bc -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>c</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

When the <command>-bc</command> option is used during a build, RPM stops once the
software has been built.  In terms of the spec file, every command in the
<command>%build</command> section will be executed.  In the following example, we've
removed the output from the <command>%prep</command> section to cut down on the
redundant output, but keep in mind that it is executed nonetheless:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bc cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make
gcc -Wall -O2  -c -I/usr/include/ncurses  cdp.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  color.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  display.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  misc.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  volume.c 
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
gcc -Wall -O2  -c -I/usr/include/ncurses  hardware.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  database.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  getline.c 
gcc -o cdp cdp.o color.o display.o misc.o volume.o hardware.o database.o
getline.o  -I/usr/include/ncurses  -L/usr/lib -lncurses
groff -Tascii -man cdp.1 | compress &gt;cdp.1.Z
+ exit 0
# 
</screen>
</figure>
After the command, we see RPM executing the <command>%prep</command> section (which
we've removed almost entirely).  Next, RPM starts executing the contents of
the <command>%build</command> section.  In our example spec file, the
<command>%build</command> section looks like this:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%build
make 
</screen>
</figure>
We see that prior to the <command>make</command> command, RPM changes directory into
<tt?>cdplayer</tt?>'s top-level directory.  RPM then starts the
<command>make</command>, which ends with the <command>groff</command> command.  At this point,
the execution of the <command>%build</command> section has been completed.  Since
the <command>-bc</command> option was used, RPM stops at this point.

The next step in the build process would be to install the newly built
software.  This is done in the <command>%install</command> section of the spec
file.  RPM can be stopped after the install has taken place by using the
<command>-bi</command> option:

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>c</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -bi</command> --- Execute <command>\%prep</command>, <command>\%build</command>, <command>\%install</command></title>
<!-- label: build-bi -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>i</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

By using the <command>-bi</command> option, RPM is directed to stop once the software
is completely built and installed on the build system.  Here's what the
output of a build using the <command>-bi</command> option looks like:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bi cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make install
chmod 755 cdp
chmod 644 cdp.1.Z
cp cdp /usr/local/bin
ln -s /usr/local/bin/cdp /usr/local/bin/cdplay
cp cdp.1 /usr/local/man/man1
+ exit 0
+ umask 022
+ echo Executing: special doc
Executing: special doc
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ DOCDIR=//usr/doc/cdplayer-1.0-1
+ rm -rf //usr/doc/cdplayer-1.0-1
+ mkdir -p //usr/doc/cdplayer-1.0-1
+ cp -ar README //usr/doc/cdplayer-1.0-1
+ exit 0
# 
</screen>
</figure>
As before, we've excised most of the previously described sections.  In
this example, the <command>%install</command> section looks like:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%install
make install
</screen>
</figure>
After the <command>%prep</command> and <command>%build</command> sections, the
<command>%install</command> section is executed.  Looking at the output, we see that
RPM changes directory into <tt?>cdplayer</tt?>'s top-level directory and
issues the <command>make install</command> command, the sole command in the
<command>%install</command> section.  The output from that point until the first
<tt?>exit 0</tt?>, is from <command>make install</command>.

The remaining commands are due to the contents of the spec file's
<command>%files</command> list.  Here's what it looks like:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
%files
%doc README
/usr/local/bin/cdp
/usr/local/bin/cdplay
/usr/local/man/man1/cdp.1
</screen>
</figure>
The line responsible is <command>%doc README</command>.  The <command>%doc</command> tag
identifies the file as being documentation.  RPM handles documentation
files by creating a directory in <tt?>/usr/doc</tt?> and placing all
documentation in it.  The <tt?>exit 0</tt?> at the end signifies the end of
the <command>%install</command> section.  RPM stops due to the <command>-bi</command> option.

The next step at which RPM's build process can be stopped is after the
software's binary package file has been created.  This is done using the
<command>-bb</command> option:

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>i</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -bb</command> --- Execute <command>\%prep</command>, <command>\%build</command>, <command>\%install</command>, package (bin)</title>
<!-- label: build-bb -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>b</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bb cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
usr/doc/cdplayer-1.0-1
usr/doc/cdplayer-1.0-1/README
usr/local/bin/cdp
usr/local/bin/cdplay
usr/local/man/man1/cdp.1
93 blocks
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
+ umask 022
+ echo Executing: %clean
Executing: %clean
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ exit 0
# 
</screen>
</figure>
After executing the <command>%prep</command>, <command>%build</command>, and
<command>%install</command> sections, and handling any special documentation files,
RPM then creates a binary package file.  In the sample output, we see that
first RPM performs automatic dependency checking.  It does this by
determining which shared libraries are required by the executable programs
contained in the package.  Next, RPM actually archives the files to be
packaged, optionally signs the package file, and outputs the finished
product.

The last part of RPM's output looks suspiciously like a section in the spec
file being executed.  In our example, there is no <command>%clean</command> section.
If there were, however, RPM would have executed any commands in the
section.  In the absence of a <command>%clean</command> section, RPM simply issues
the usual <command>cd</command> commands and exits normally.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>b</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -ba</command> --- Execute <command>\%prep</command>, <command>\%build</command>, <command>\%install</command>, package (bin, src)</title>
<!-- label: build-ba -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>a</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>-ba</command> option directs RPM to perform <emphasis>all</emphasis> the stages in
building a package.  With this one command, RPM:

<itemizedlist mark="bullet">
<listitem>
<para>
Unpacks the original sources.

</para>
</listitem>

<listitem>
<para>
Applies patches (if desired).

</para>
</listitem>

<listitem>
<para>
Builds the software.

</para>
</listitem>

<listitem>
<para>
Installs the software.

</para>
</listitem>

<listitem>
<para>
Creates the binary package file.

</para>
</listitem>

<listitem>
<para>
Creates the source package file.

</para>
</listitem>

</itemizedlist>
That's quite a bit of work for one command!  Here it is, in action:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
&hellip;
Executing: %clean
&hellip;
+ exit 0
Source Packaging: cdplayer-1.0-1
cdplayer-1.0.spec
cdplayer-1.0.tgz
80 blocks
Generating signature: 0
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
# 
</screen>
</figure>
As in previous examples, RPM executes the <command>%prep</command>,
<command>%build</command>, and <command>%install</command> sections, handles any special
documentation files, creates a binary package file, and cleans up after
itself.

The final step in the build process is to create a source package file.  As
the output shows, it consists of the spec file and the original sources.  A
source package may optionally include one or more patch files, although
in our example, <tt?>cdplayer</tt?> requires none.

At the end of a build using the <command>-ba</command> option, the software has been
successfully built and packaged in both binary and source form.  But there
are a few more build-time options that we can use.  One of them is the
<command>-bl</command> option:

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>a</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm -bl</command> --- Check <command>\%files</command> list</title>
<!-- label: build-bl -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>l</command></primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

There's one last letter that may be specified with <command>rpm -b</command>, but
unlike the others, which indicate the stage at which the build process is
to stop, this option performs a variety of checks on the <command>%files</command>
list in the named spec file.  When <command>l</command> is added to <command>rpm -b</command>,
the following checks are performed:

<itemizedlist mark="bullet">
<listitem>
<para>
Expands the spec file's <command>%files</command> list and checks that each
file listed actually exists.

</para>
</listitem>

<listitem>
<para>
Determines what shared libraries the software requires by examining
every executable file listed.

</para>
</listitem>

<listitem>
<para>
Determines what shared libraries are provided by the package.

</para>
</listitem>

</itemizedlist>
Why is it necessary to do all this checking?  When would it be useful?
Keep in mind that the <command>%files</command> list must be generated manually.  By
using the <command>-bl</command> option, the following steps are all that's necessary
to create a <command>%files</command> list:

<itemizedlist mark="bullet">
<listitem>
<para>
Writing the <command>%files</command> list.

</para>
</listitem>

<listitem>
<para>
Using the <command>-bl</command> option to check the <command>%files</command> list.

</para>
</listitem>

<listitem>
<para>
Making any necessary changes to the <command>%files</command> list.

</para>
</listitem>

</itemizedlist>
It may take more than one iteration through these steps, but eventually the
list check will pass.  Using the <command>-bl</command> option to check the
<command>%files</command> list is certainly better than starting a two-hour package
build, only to find out at the very end that the list contains a misspelled
filename.

Here's an example of the <command>-bl</command> option in action:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bl cdplayer-1.0.spec</userinput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
#
</screen>
</figure>
It's hard to see exactly what RPM is doing from the output, but if we add
<command>-vv</command>, we can get a bit more information:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bl -vv cdplayer-1.0.spec</userinput>
D: Switched to BASE package
D: Source(0) = sunsite.unc.edu:/pub/Linux/apps/sound/cds/cdplayer-1.0.tgz
D: Switching to part: 12
D: fileFile = 
D: Switched to package: (null)
D: Switching to part: 2
D: fileFile = 
D: Switching to part: 3
D: fileFile = 
D: Switching to part: 4
D: fileFile = 
D: Switching to part: 10
D: fileFile = 
D: Switched to package: (null)
* Package: cdplayer
File List Check: cdplayer-1.0-1
D: ADDING: /usr/doc/cdplayer-1.0-1
D: ADDING: /usr/doc/cdplayer-1.0-1/README
D: ADDING: /usr/local/bin/cdp
D: ADDING: /usr/local/bin/cdplay
D: ADDING: /usr/local/man/man1/cdp.1
D: md5(/usr/doc/cdplayer-1.0-1/README) = 2c149b2fb1a4d65418131a19b242601c
D: md5(/usr/local/bin/cdp) = 0f2a7a2f81812c75fd01c52f456798d6
D: md5(/usr/local/bin/cdplay) = d41d8cd98f00b204e9800998ecf8427e
D: md5(/usr/local/man/man1/cdp.1) = b32cc867ae50e2bdfa4d6780b084adfa
Finding dependencies...
D: Adding require: libncurses.so.2.0
D: Adding require: libc.so.5
Requires (2): libc.so.5 libncurses.so.2.0
# 
</screen>
</figure>
Looking at this more verbose output, it's easy to see there's a great deal
going on.  Some of it is not directly pertinent to checking the
<command>%files</command> list, however.  For example, the output extending from the
first line, to the line reading <tt?>* Package: cdplayer</tt?>, reflects
processing that takes place during actual package building, and can be
ignored.

Following that section is the actual <command>%files</command> list check.  In this
section, every file named in the <command>%files</command> list is checked to make
sure it exists.  The phrase, <tt?>ADDING:</tt?>, again reflects RPM's package
building roots.  When using the <command>-bl</command> option, however, RPM is
simply making sure the files exist on the build system.  If the
<command>--timecheck</command> option (described a bit later, on page
<xref linkend="build--timecheck">) is present, the checks required by that option
are performed here, as well.

After the list check, the MD5 checksums of each file are calculated and
displayed.  While this information is vital during actual package building,
it is not used when using the <command>-bl</command> option.

Finally, RPM determines which shared libraries the listed files require.
In this case, there are only two --- <tt?>libc.so.5</tt?>, and
<tt?>libncurses.so.2.0</tt?>.  While not strictly a part of the list-checking
process, displaying shared library dependencies can be quite helpful at
this point.  It can point out possible problems, such as assuming that the
target systems have a certain library installed when, in fact, they do
not.

So far, we've only seen what happens when the <command>%files</command> list is
correct.  Let's see what happens where the list has problems.  In this
example, we've added a bogus file to the package's <command>%files</command> list:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bl cdplayer-1.0.spec</userinput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
File not found: /usr/local/bin/bogus
Build failed.
#
</screen>
</figure>
Reflecting more of its package building roots, <command>rpm -bl</command> says that
the "build failed".  But the bottom line is that there is no such file
as <tt?>/usr/bin/bogus</tt?>.  In this example we made the name obviously
wrong, but in a more real-world setting, the name will more likely be a
misspelling in the <command>%files</command> list.  OK, let's correct the
<command>%files</command> list and try again:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bl cdplayer-1.0.spec</userinput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
File not found: /usr/local/bin/cdplay
Build failed.
#
</screen>
</figure>
Another error!  In this case the file is spelled correctly, but it is not
on the build system, even though it should be.  Perhaps it was deleted
accidentally.  In any case, let's rebuild the software and try again:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bi cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
ln -s /usr/local/bin/cdp /usr/local/bin/cdplay
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
# 
# <userinput>rpm -bl cdplayer-1.0.spec</userinput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
#
</screen>
</figure>
Done!  The moral to this story is that using <command>rpm -bl</command> and fixing
the error it flagged doesn't necessarily mean your <command>%files</command> list is
ready for prime-time:  Always run it again to make sure!

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!build stages of!<command>l</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--short-circuit</command> --- Force build to start at particular stage</title>
<!-- label: build--short-circuit -->
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!options</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>short-circuit@<command>--short-circuit</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Although it sounds dangerous, the <command>--short-circuit</command> option can be
your friend.  This option is used during the initial development of a
package.  Earlier in the chapter, we explored stopping RPM's build process
at different stages.  Using <command>--short-circuit</command>, we can <emphasis>start</emphasis>
the build process at different stages.

One time that <command>--short-circuit</command> comes in handy is when you're
trying to get software to build properly.  Just think what it would be like
--- you're hacking away at the sources, trying a build, getting an error,
and hacking some more to fix that error.  Without
<command>--short-circuit</command>, you'd have to:

<orderedlist>
<listitem>
<para>
Make your change to the sources.

</para>
</listitem>

<listitem>
<para>
Use <command>tar</command> to create a new source archive.

</para>
</listitem>

<listitem>
<para>
Start a build with something like <command>rpm -bc</command>.

</para>
</listitem>

<listitem>
<para>
See another bug.

</para>
</listitem>

<listitem>
<para>
Go back to step 1.

</para>
</listitem>

</orderedlist>
Pretty cumbersome!  Since RPM's build process is designed to start with the
sources in their original <command>tar</command> file, unless your modifications end
up in that <command>tar</command> file, they won't be used in the next
build.
<footnote>
<para>
As we mentioned in chapter <xref linkend="rpm-basics">, if the
original sources need to be modified, the modifications should be kept as a
separate set of patches.  However, during development, it makes more sense
to not generate patches every time a change to the original source is made.
</para>
</footnote>

But there's another way.  Just follow these steps:

<orderedlist>
<listitem>
<para>
Place the original source <command>tar</command> file in RPM's <tt?>SOURCES</tt?>
directory.

</para>
</listitem>

<listitem>
<para>
Create a partial spec file in RPM's <tt?>SPECS</tt?> directory (Be sure
to include a valid <command>Source</command> line).

</para>
</listitem>

<listitem>
<para>
Issue an <command>rpm -bp</command> to properly create the build environment.

</para>
</listitem>

</orderedlist>
Now use <command>--short-circuit</command> to attempt a compile.  Here's an
example:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bc --short-circuit cdplayer-1.0.spec</userinput>
* Package: cdplayer
+ umask 022
+ echo Executing: %build
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make
gcc -Wall -O2  -c -I/usr/include/ncurses  cdp.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  color.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  display.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  misc.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  volume.c 
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
gcc -Wall -O2  -c -I/usr/include/ncurses  hardware.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  database.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  getline.c 
gcc -o cdp cdp.o color.o display.o misc.o volume.o
     hardware.o database.o getline.o  -I/usr/include/ncurses
     -L/usr/lib -lncurses
groff -Tascii -man cdp.1 | compress &gt;cdp.1.Z
+ exit 0
# 
</screen>
</figure>
Normally, the <command>-bc</command> option instructs RPM to <emphasis>stop</emphasis> the build
after the <command>%build</command> section of the spec file has been executed.  By
adding <command>--short-circuit</command>, however, RPM <emphasis>starts</emphasis> the build by
executing the <command>%build</command> section and stops when everything in
<command>%build</command> has been executed.

There is only one other build stage that can be
<command>--short-circuit</command>'ed, and that is the install stage.
The reason for this restriction is to make it difficult to bypass RPM's
use of pristine sources.  If it were possible to <command>--short-circuit</command>
to <command>-bb</command> or <command>-ba</command>, a package builder might take the "easy"
way out and simply hack at the build tree until the software built
successfully, then package the hacked sources.  So, RPM will only
<command>--short-circuit</command> to <command>-bc</command> or <command>-bi</command>.  Nothing else
will do.

What exactly does an <command>rpm -bi --short-circuit</command> do, anyway?  Like
an <command>rpm -bc --short-circuit</command>, it starts executing at the named
stage, which in this case is <command>%install</command>.  Note that the build
environment must be ready to perform an install before attempting to
<command>--short-circuit</command> to the <command>%install</command> stage.  If the
software installs via <command>make install</command>, <command>make</command> will
automatically compile the software anyway.

And what happens if the build environment isn't ready and a
<command>--short-circuit</command> is attempted?  Let's see:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bi --short-circuit cdplayer-1.0.spec</userinput>
* Package: cdplayer
+ umask 022
+ echo Executing: %install
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
/var/tmp/rpmbu01157aaa: cdplayer-1.0: No such file or directory
Bad exit status
# 
</screen>
</figure>
RPM blindly started executing the <command>%install</command> stage, but came to an
abrupt halt when it attempted to change directory into
<tt?>cdplayer-1.0</tt?>, which didn't exist.  After giving a descriptive
error message, RPM exited with a failure status.  Except for some minor
differences, <command>rpm -bc</command> would have failed in the same way.

<indexterm>
<primary>short-circuit@<command>--short-circuit</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--buildarch <emphasis>&lt;arch&gt;</command></emphasis> --- Perform Build For the <command><emphasis>&lt;arch&gt;</command></emphasis> Architecture</title>
<!-- label: build--buildarch -->
<indexterm>
<primary>buildarch@<command>--buildarch</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--buildarch</command> option is used to override RPM's architecture
detection logic.  The option is followed by the desired architecture name.
Here's an example:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --buildarch i486 cdplayer-1.0.spec</userinput>
* Package: cdplayer
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/RPMS/i486/cdplayer-1.0-1.i486.rpm
&hellip;
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
#
</screen>
</figure>
We've removed most of RPM's output from this example, but the main thing we
can see from this example is that the package was built for the
<tt?>i486</tt?> architecture, due to the inclusion of the
<command>--buildarch</command> option on the command line.  We can also see that
RPM wrote the binary package in  the architecture-specific directory,
<tt?>/usr/src/redhat/RPMS/i486</tt?>.  Using RPM's <command>--queryformat</command>
option confirms the package's architecture:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -qp --queryformat '%{arch</userinput>\n' /usr/src/redhat/RPMS/i486/cdplayer-1.0-1.i486.rpm}
i486
#
</screen>
</figure>
For more information on build packages for multiple architectures, please
see Chapter <xref linkend="rpm-multi">.

<indexterm>
<primary>buildarch@<command>--buildarch</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--buildos <emphasis>&lt;os&gt;</command></emphasis> --- Perform Build For the <command><emphasis>&lt;os&gt;</command></emphasis> Operating System</title>
<!-- label: build--buildos -->
<indexterm>
<primary>buildos@<command>--buildos</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--buildos</command> option is used to override RPM's operating system
detection logic.  The option is followed by the desired operating system
name.  Here's an example:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --buildos osf1 cdplayer-1.0.spec</userinput>
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
Source Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
#
</screen>
</figure>
There's nothing in the build output that explicitly states the build
operating system as been set to <tt?>osf1</tt?>.  Let's see if
<command>--queryformat</command> will tell us:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -qp --queryformat '%{os</userinput>\n' /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm}
osf1
#
</screen>
</figure>
The package was indeed built for the specified operating system.  For more
information on building packages for multiple operating systems, please see
Chapter <xref linkend="rpm-multi">.

<indexterm>
<primary>buildos@<command>--buildos</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--sign</command> --- Add a Digital Signature to the Package</title>
<!-- label: build--sign -->
<indexterm>
<primary>sign@<command>--sign</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--sign</command> option directs RPM to add a digital signature to the
package being built.  Currently, this is done using PGP.  Here's an example
of <command>--sign</command> in action:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --sign cdplayer-1.0.spec</userinput>
Enter pass phrase: <userinput>passphrase</userinput> (not echoed)
Pass phrase is good.
* Package: cdplayer
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
&hellip;
Source Packaging: cdplayer-1.0-1
&hellip;
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
#
</screen>
</figure>
The most obvious effect of adding the <command>--sign</command> option to a build
command is that RPM then asks for your private key's passphrase.  After
entering the passphrase (which isn't echoed), the build proceeds as usual.
The only other difference between this and a non-signed build is that the
<tt?>Generating signature:</tt?> lines have a non-zero value.

Let's check the source and binary packages we've just created and see if
they are, in fact, signed:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm --checksig /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm</userinput>
/usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm: size pgp md5 OK
# <userinput>rpm --checksig /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm</userinput>
/usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm: size pgp md5 OK
#
</screen>
</figure>
The fact that there is a <command>pgp</command> in <command>--checksig</command>'s output
indicates that the packages have been signed.

For more information on signing packages, please see Chapter
<xref linkend="rpm-pgp">.  Appendix <xref linkend="pgp-intro"> contains information on
obtaining and installing PGP.

<indexterm>
<primary>sign@<command>--sign</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--test</command> --- Create, Save Build Scripts For Review</title>
<!-- label: build--test -->
<indexterm>
<primary>test@<command>--test</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

There are times when it might be necessary to get a more in-depth view of a
particular build.  By using the <command>--test</command> option, it's easy.  When
<command>--test</command> is added to a build command, the scripts RPM would
normally use to actually perform the build, are created and saved for you
to review.  Let's see how it works:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --test cdplayer-1.0.spec</userinput>
* Package: cdplayer
#
</screen>
</figure>
Unlike a normal build, there's not much output.  But the <command>--test</command>
option has caused a set of scripts to be written and saved for you.  The
question is: Where are they?

If you are using a customized rpmrc file, the scripts will be written to
the directory specified by the rpmrc entry <command>tmppath</command>.  If you
haven't changed this setting, RPM, by default, writes the scripts in
<tt?>/var/tmp</tt?>.  Here they are:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>ls -l /var/tmp</userinput>
total 4
-rw-rw-r--   1 root     root          670 Sep 17 20:35 rpmbu00236aaa
-rw-rw-r--   1 root     root          449 Sep 17 20:35 rpmbu00236baa
-rw-rw-r--   1 root     root          482 Sep 17 20:35 rpmbu00236caa
-rw-rw-r--   1 root     root          552 Sep 17 20:35 rpmbu00236daa
# 
</screen>
</figure>
Each file contains a script that performs a given part of the build.
Here's the first file:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
#!/bin/sh -e
# Script generated by rpm

RPM_SOURCE_DIR="/usr/src/redhat/SOURCES"
RPM_BUILD_DIR="/usr/src/redhat/BUILD"
RPM_DOC_DIR="/usr/doc"
RPM_OPT_FLAGS="-O2 -m486 -fno-strength-reduce"
RPM_ARCH="i386"
RPM_OS="Linux"
RPM_ROOT_DIR="/tmp/cdplayer"
RPM_BUILD_ROOT="/tmp/cdplayer"
RPM_PACKAGE_NAME="cdplayer"
RPM_PACKAGE_VERSION="1.0"
RPM_PACKAGE_RELEASE="1"
set -x

umask 022

echo Executing: %prep
cd /usr/src/redhat/BUILD

cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</screen>
</figure>
As we can see, this script contains the <command>%prep</command> section from the
spec file.  The script starts off by defining a number of environment
variables and then leads into the <command>%prep</command> section.  In the spec
file used in this build, the <command>%prep</command> section consists of a single
<command>%setup</command> macro.  In this file, we can see exactly how RPM expands
that macro.  The remaining files follow the same basic layout --- a section
defining environment variables, followed by the commands to be executed.

Note that the <command>--test</command> option will only create script files for
each build stage, as specified in the command line.  For example, if the
above command was changed to:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bp --test cdplayer-1.0.spec</userinput>
#
</screen>
</figure>
only one script file, containing the <command>%prep</command> commands,  would be
written.  In any case, no matter what RPM build command is used, the
<command>--test</command> option can let you see exactly what is going to happen
during a build.

<indexterm>
<primary>test@<command>--test</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--clean</command> --- Clean up after build</title>
<!-- label: build--clean -->
<indexterm>
<primary>clean@<command>--clean</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--clean</command> option can be used to ensure that the package's
build directory tree is removed at the end of a build.  Although it can be
used with any build stage, it doesn't always make much sense to do so:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bp --clean cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
+ echo Executing: sweep
Executing: sweep
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ exit 0
# 
</screen>
</figure>
In this example, we see a typical <command>%prep</command> section being executed.
The line "<tt?>+ echo Executing: sweep</tt?>" indicates the start of
<command>--clean</command>'s activity.  After changing directory into the build
directory, RPM then issues a recursive delete on the package's top-level
directory.  

As we noted above, this particular example doesn't make much sense.
We're only executing the <command>%prep</command> section, which creates the
package's build tree, and using <command>--clean</command>, which removes it!
Using <command>--clean</command> with the <command>-bc</command> option isn't very
productive either, as the newly built software remains in the build tree.
Once again, there would be no remnants left after <command>--clean</command> has
done its thing.

Normally, the <command>--clean</command> option is used once the software builds
and can be packaged successfully.  It is particularly useful when more than
one package is to be built, since <command>--clean</command> ensures that the
filesystem holding the build area will not fill up with build trees from
each package.

Note also that the <command>--clean</command> option only removes the files that
reside in the software's build tree.  If there are any files that the build
creates outside of this hierarchy, it will be necessary to write a script
for the spec file's <command>%clean</command> section.

<indexterm>
<primary>clean@<command>--clean</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--buildroot <emphasis>&lt;path&gt;</command></emphasis> --- Execute <command>\%install</command> using <command><emphasis>&lt;path&gt;</command></emphasis> as the root</title>
<!-- label: build--buildroot -->
<indexterm>
<primary>buildroot@<command>--buildroot</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--buildroot</command> option can make two difficult situations much
easier:

<itemizedlist mark="bullet">
<listitem>
<para>
Performing a build without impacting the build system.

</para>
</listitem>

<listitem>
<para>
Allowing non-root users to build packages.

</para>
</listitem>

</itemizedlist>
Let's study the first situation in a bit more detail.  Say, for example,
that <tt?>sendmail</tt?> is to be packaged.  In the course of creating a
<tt?>sendmail</tt?> package, the software must be installed.  This would mean
that critical <tt?>sendmail</tt?> files, such as <tt?>sendmail.cf</tt?> and
{aliases}, would be overwritten.  Mail handling on the build system would
almost certainly be disrupted.

In the second case, it's certainly possible to set permissions such that
non-root users can install software, but highly unlikely that any system
administrator worth their salt would do so.  What can be done to make these
situations more tenable?

The <command>--buildroot</command> option is used to instruct RPM to use a
directory other than <tt?>/</tt?> as a "build root".  This phrase is a bit
misleading, in that the build root is <emphasis>not</emphasis> the root directory under
which the software is built.  Rather, it is the root directory for the
install phase of the build.  When a build root is not specified, the
software being packaged is installed relative to the build system's root
directory "<tt?>/</tt?>".

However, it's not enough to just specify a build root on the command line.
The spec file for the package must be set up to support a build root.  If
you don't make the necessary changes, this is what you'll see:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --buildroot /tmp/foo cdplayer-1.0.spec</userinput>
Package can not do build prefixes
Build failed.
#
</screen>
</figure>
Chapter <xref linkend="rpm-anywhere"> has complete instructions on the modifications
necessary to configure a package to use an alternate build root, as well as
methods to permit users to build packages without root access.  Assuming
that the necessary modifications have been made, here is what the build
would look like:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --buildroot /tmp/foonly cdplayer-1.0.spec</userinput>
* Package: cdplayer
Executing: %prep
+ cd /usr/src/redhat/BUILD
&hellip;
+ exit 0
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
&hellip;
+ exit 0
+ umask 022
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make ROOT=/tmp/foonly install
install -m 755 -o 0 -g 0 -d /tmp/foonly/usr/local/bin/
install -m 755 -o 0 -g 0 cdp /tmp/foonly/usr/local/bin/cdp
rm -f /tmp/foonly/usr/local/bin/cdplay
ln -s /tmp/foonly/usr/local/bin/cdp /tmp/foonly/usr/local/bin/cdplay
install -m 755 -o 0 -g 0 -d /tmp/foonly/usr/local/man/man1/
install -m 755 -o 0 -g 0 cdp.1 /tmp/foonly/usr/local/man/man1/cdp.1
+ exit 0
Executing: special doc
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ DOCDIR=/tmp/foonly//usr/doc/cdplayer-1.0-1
+ rm -rf /tmp/foonly//usr/doc/cdplayer-1.0-1
+ mkdir -p /tmp/foonly//usr/doc/cdplayer-1.0-1
+ cp -ar README /tmp/foonly//usr/doc/cdplayer-1.0-1
+ exit 0
Binary Packaging: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
usr/doc/cdplayer-1.0-1
usr/doc/cdplayer-1.0-1/README
usr/local/bin/cdp
usr/local/bin/cdplay
usr/local/man/man1/cdp.1
93 blocks
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
+ umask 022
+ echo Executing: %clean
Executing: %clean
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ exit 0
Source Packaging: cdplayer-1.0-1
cdplayer-1.0.spec
cdplayer-1.0.tgz
82 blocks
Generating signature: 0
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
# 
</screen>
</figure>
As the somewhat edited output shows, the <command>%prep</command>, <command>%build</command>,
and <command>%install</command> sections are executed in RPM's normal build
directory.  However, the <command>--buildroot</command> option comes into play when
the <command>make install</command> is done.  As we can see, the <tt?>ROOT</tt?>
variable is set to <tt?>/tmp/foonly</tt?>, which was the value following
<command>--buildroot</command> on the command line.  From that point on, we can see
that <command>make</command> substituted the new build root value during the install
phase.

The build root is also used when documentation files are installed.  The
documentation directory <tt?>cdplayer-1.0-1</tt?> is created in
<tt?>/tmp/foonly/usr/doc</tt?>, and the README file is placed in it.

The only remaining difference that results from using
<command>--buildroot</command>, is that the files to be included in the binary
package are not located relative to the build system's root directory.
Instead they are located relative to the build root <tt?>/tmp/foonly</tt?>.
The resulting binary and source package files are functionally equivalent
to packages built without the use of <command>--buildroot</command>.

<sect3 id="s3-rpm-b-command-">
<title>Using <command>--buildroot</command> Can Bite You!</title>
<!-- label: buildroot-bite -->
<indexterm>
<primary>buildroot@<command>--buildroot</command> option!warning</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Although the <command>--buildroot</command> option can solve some problems, using a
build root can actually be dangerous.  How?  Consider the following
situation:

<itemizedlist mark="bullet">
<listitem>
<para>
A spec file is configured to have a build root of
<tt?>/tmp/blather</tt?>, for instance.

</para>
</listitem>

<listitem>
<para>
In the <command>%prep</command> section
<footnote>
<para>
Or the <command>%clean</command>
section, it doesn't matter --- the end result is the same.
</para>
</footnote>
, there is an
<command>rm -rf \$RPM_BUILD_ROOT</command> command to clean out any old installed
software.

</para>
</listitem>

<listitem>
<para>
You decide to build the software so that it installs relative to your
system's root directory, so you enter the following command: "<command>rpm
-ba --buildroot / foo.spec</command>".

</para>
</listitem>

</itemizedlist>
The end result?  Since specifying "<tt?>/</tt?>" as the build root sets
\$RPM_BUILD_ROOT to "<tt?>/</tt?>", that innocuous little <command>rm -rf
\$RPM_BUILD_ROOT</command> turns into <command>rm -rf /</command>!  A recursive delete,
starting at your system's root directory, might not be a total disaster if
you catch it quickly, but in either case, you'll be testing your ability to
restore from backup\dots\   Er, you <emphasis>do</emphasis> have backups, don't you?

The moral of this story is to be <emphasis>very</emphasis> careful when using
<command>--buildroot</command>.  A good rule of thumb is to always specify a unique
build root.  For example, instead of specifying <tt?>/tmp</tt?> as a build
root (and possibly losing your system's directory for holding temporary
files), use the path <tt?>/tmp/mypackage</tt?>, where the directory
<tt?>mypackage</tt?> is used only by the package you're building.

<indexterm>
<primary>buildroot@<command>--buildroot</command> option!warning|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>buildroot@<command>--buildroot</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect3>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--timecheck <emphasis>&lt;secs&gt;</command></emphasis> --- Print a warning if files to be packaged are over <command><emphasis>&lt;secs&gt;</command></emphasis> old</title>
<!-- label: build--timecheck -->
<indexterm>
<primary>timecheck@<command>--timecheck</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

While it's possible to detect many errors in the <command>%files</command> list
using <command>rpm -bl</command>, there is another type of problem that can't be
detected.  Consider the following scenario:

<itemizedlist mark="bullet">
<listitem>
<para>
A package you're building creates the file <tt?>/usr/bin/foo</tt?>.

</para>
</listitem>

<listitem>
<para>
Because of a problem with the package's makefile,
<tt?>foo</tt?> is never copied into <tt?>/usr/bin</tt?>.

</para>
</listitem>

<listitem>
<para>
An older, incompatible version of <tt?>foo</tt?>, created several
months ago, already exists in <tt?>/usr/bin</tt?>.

</para>
</listitem>

<listitem>
<para>
RPM creates the binary package file.

</para>
</listitem>

</itemizedlist>
Is the incompatible <tt?>/usr/bin/foo</tt?> included in the package?  You bet
it is!  If only there was some way for RPM to catch this type of problem&hellip;

Well, there is!  By adding <command>--timecheck</command>, followed by a number,
RPM will check each file being packaged, to see if the file is more than the
specified number of seconds old.  If it is, a warning message is
displayed.  The <command>--timecheck</command> option works with either the
<command>-ba</command> or <command>-bl</command> options.  Here's an example using
<command>-bl</command>:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bl --timecheck 3600 cdplayer-1.0.spec</userinput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
warning: TIMECHECK failure: /usr/doc/cdplayer-1.0-1/README
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
# 
</screen>
</figure>
In this example, the file <tt?>/usr/doc/cdplayer-1.0-1/README</tt?> is more
than 3,600 seconds, or one hour, old.  If we take a look at the file, we
find that it is:
<footnote>
<para>
It should be noted that the package was built
<emphasis>substantially</emphasis> later than November of 1995!
</para>
</footnote>

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>ls -al /usr/doc/cdplayer-1.0-1/README</userinput>
-rw-r--r--   1 root     root         1085 Nov 10  1995 README
#
</screen>
</figure>
In this particular case, the warning from <command>--timecheck</command> is no
cause for alarm.  Since the <tt?>README</tt?> file was simply copied from the
original source, which was created November 10th, 1995, its date is
unchanged.  If the file had been an executable or a library that was
supposedly built recently, <command>--timecheck</command>'s warning should be taken
more seriously.

If you'd like to set a default time check value of one hour, you can
include the following line in your <tt?>rpmrc</tt?> file:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
timecheck: 3600
</screen>
</figure>
This value can still be overridden by a value on the command line, if
desired.  For more information on the use of <tt?>rpmrc</tt?> files, see
Appendix <xref linkend="rpmrc-file">.

<indexterm>
<primary>timecheck@<command>--timecheck</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>-vv</command> --- Display debugging information</title>
<!-- label: build-vv -->
<indexterm>
<primary>vv@<command>-vv</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Unlike most other RPM commands, there is no <command>-v</command> option for
<command>rpm -b</command>.  That's because the command's default is to be verbose.
However, even more information can be obtained by adding <command>-vv</command>.
Here's an example:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -bp -vv cdplayer-1.0.spec</userinput>
D: Switched to BASE package
D: Source(0) = sunsite.unc.edu:/pub/Linux/apps/sound/cds/cdplayer-1.0.tgz
D: Switching to part: 12
D: fileFile = 
D: Switched to package: (null)
D: Switching to part: 2
D: fileFile = 
D: Switching to part: 3
D: fileFile = 
D: Switching to part: 4
D: fileFile = 
D: Switching to part: 10
D: fileFile = 
D: Switched to package: (null)
* Package: cdplayer
D: RUNNING: %prep
+ umask 022
+ echo Executing: %prep
Executing: %prep
+ cd /usr/src/redhat/BUILD
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz
+ tar -xvvf -
drwxrwxr-x root/users        0 Aug  4 22:30 1996 cdplayer-1.0/
-rw-r--r-- root/users    17982 Nov 10 01:10 1995 cdplayer-1.0/COPYING
&hellip;
-rw-r--r-- root/users     1515 Nov 10 01:10 1995 cdplayer-1.0/volume.h
+ [ 0 -ne 0 ]
+ cd cdplayer-1.0
+ cd /usr/src/redhat/BUILD/cdplayer-1.0
+ chown -R root.root .
+ chmod -R a+rX,g-w,o-w .
+ exit 0
# 
</screen>
</figure>
Most of the output generated by the <command>-vv</command> option is preceded by a
<tt?>D:</tt?>.  In this example, the additional output represents RPM's
internal processing during the start of the build process.  Using the
<command>-vv</command> option with other build commands will produce different
output.

<indexterm>
<primary>vv@<command>-vv</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--quiet</command> --- Produce as Little Output as Possible</title>
<!-- label: build--quiet -->

<indexterm>
<primary>quiet@<command>--quiet</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

As we mentioned above, the build command is normally verbose.  The
<command>--quiet</command> option can be used to cut down on the command's output:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm -ba --quiet cdplayer-1.0.spec</userinput>
* Package: cdplayer
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
90 blocks
82 blocks
#
</screen>
</figure>
This is the entire output from a package build of <tt?>cdplayer</tt?>.  Note
that warning messages (actually, anything sent to stdout) are still
printed.

<indexterm>
<primary>quiet@<command>--quiet</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>--rcfile <emphasis>&lt;rcfile&gt;</command></emphasis> --- Set alternate rpmrc file to <command><emphasis>&lt;rcfile&gt;</command></emphasis></title>
<!-- label: build--rcfile -->
<indexterm>
<primary>rcfile@<command>--rcfile</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--rcfile</command> option is used to specify a file containing default
settings for RPM.  Normally, this option is not needed.  By default, RPM
uses <tt?>/etc/rpmrc</tt?> and a file named <tt?>.rpmrc</tt?> located in your
login directory.

This option would be used if there was a need to switch between several
sets of RPM defaults.  Software developers and package builders will
normally be the only people using the <command>--rcfile</command> option.  For more
information on <tt?>rpmrc</tt?> files, see Appendix <xref linkend="rpmrc-file">.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!options|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>rcfile@<command>--rcfile</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

</sect1>

<sect1 id="s1-rpm-b-command-">
<title>Other Build-related Commands</title>
<indexterm>
<primary>rpm -b@<command>rpm -b</command>!related commands</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

There are two other commands that also perform build-related functions.
However, they do not use the <command>rpm -b</command> command syntax that we've been
studying so far.  Instead of specifying the name of the spec file, as with
<command>rpm -b</command>, it's necessary to specify the name of the source package
file.

Why the difference in syntax?  The reason has to do with the differing
functions of these commands.  Unlike <command>rpm -b</command>, where the name of the
game is to get software packaged into binary and source package files,
these commands use an already-existing source package file as input.  Let's
take a look at them:

<sect2 id="s2-rpm-b-command-">
<title><command>rpm --recompile</command> --- What Does it Do?</title>
<indexterm>
<primary>recompile@<command>--recompile</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

The <command>--recompile</command> option directs RPM to perform the following
steps:

<itemizedlist mark="bullet">
<listitem>
<para>
Install the specified source package file.

</para>
</listitem>

<listitem>
<para>
Unpack the original sources.

</para>
</listitem>

<listitem>
<para>
Build the software.

</para>
</listitem>

<listitem>
<para>
Install the software.

</para>
</listitem>

<listitem>
<para>
Remove the software's build directory structure.

</para>
</listitem>

</itemizedlist>
While you might think this sounds a great deal like an install of the
source package file, followed by an <command>rpm -bi</command>, this is not entirely
the case.  Using <command>--recompile</command>, the only file required is the
source package file.  After the software is built and installed, the only
thing left, other than the newly installed software, is the original source
package file.

The <command>--recompile</command> option is normally used when a previously
installed package needs to be recompiled.  <command>--recompile</command> comes in
handy when software needs to be compiled against a new version of the
kernel.

Here's what RPM displays during a <command>--recompile</command>:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm --recompile cdplayer-1.0-1.src.rpm</userinput>
Installing cdplayer-1.0-1.src.rpm
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Executing: sweep
&hellip;
+ exit 0
# 
</screen>
</figure>
The very first line shows RPM installing the source package.  After that
are ordinary executions of the <command>%prep</command>, <command>%build</command>, and
<command>%install</command> sections of the spec file.  Finally, the cleanup of
the software's build directory takes place, just as if the
<command>--clean</command> option had been specified.

Since <command>rpm -i</command> or <command>rpm -U</command> are not being used to install the
software, the RPM database is not updated during a <command>--recompile</command>.
This means that doing a <command>--recompile</command> on an already-installed
package may result in problems down the road, when RPM is used to upgrade
or verify the package.

<indexterm>
<primary>recompile@<command>--recompile</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

<sect2 id="s2-rpm-b-command-">
<title><command>rpm --rebuild</command> --- What Does it Do?</title>
<indexterm>
<primary>rebuild@<command>--rebuild</command> option</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

Package builders, particularly those that create packages for multiple
architectures, often need to build their packages starting from the
original sources.  The <command>--rebuild</command> option does this, starting
from a source package file.  Here is the list of steps it performs:

<itemizedlist mark="bullet">
<listitem>
<para>
Install the specified source package file.

</para>
</listitem>

<listitem>
<para>
Unpack the original sources.

</para>
</listitem>

<listitem>
<para>
Build the software.

</para>
</listitem>

<listitem>
<para>
Install the software.

</para>
</listitem>

<listitem>
<para>
Create a binary package file.

</para>
</listitem>

<listitem>
<para>
Remove the software's build directory tree.

</para>
</listitem>

</itemizedlist>
Like the <command>--recompile</command> option, <command>--rebuild</command> cleans up
after itself.  The only difference between the two commands is the fact
that <command>--rebuild</command> also creates a binary package file.  The only
remnants of a <command>--rebuild</command> are the original source package, the
newly installed software, and a new binary package file.

Package builders find this command especially handy, as it allows them to
create new binary packages using one command, with no additional cleanups
required.  There are several times when <command>--rebuild</command> is normally
used:

<itemizedlist mark="bullet">
<listitem>
<para>
When the build environment (eg. compilers, libraries, etc.) has
changed.

</para>
</listitem>

<listitem>
<para>
When binary packages for a different architecture are to be built.

</para>
</listitem>

</itemizedlist>
Here's an example of the <command>--rebuild</command> option in action:

<figure id="sc-rpm-b-command-">
<title>*** Enter New Title Here ***</title>
<screen width="60">
# <userinput>rpm --rebuild cdplayer-1.0-1.src.rpm</userinput>
Installing cdplayer-1.0-1.src.rpm
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
&hellip;
Executing: %clean
&hellip;
+ exit 0
Executing: sweep
&hellip;
+ exit 0
#
</screen>
</figure>
The very first line shows RPM installing the source package.  The lines
after that are ordinary executions of the <command>%prep</command>,
<command>%build</command>, and <command>%install</command> sections of the spec file.  Next,
a binary package file is created.  Finally, the spec file's
<command>%clean</command> section (if one exists) is executed.  The cleanup of the
software's build directory takes place, just as if the <command>--clean</command>
option had been specified.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>!related commands|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

<indexterm>
<primary>rebuild@<command>--rebuild</command> option|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

That completes our overview of the commands used to build packages with
RPM.  In the next chapter, we'll look at the various macros that are
available and how they can make life easier for the package builder.

<indexterm>
<primary>rpm -b@<command>rpm -b</command>|)</primary>
<secondary></secondary>
<tertiary></tertiary>
<see></see>
</indexterm>

</sect2>

</sect1>

</chapter>

