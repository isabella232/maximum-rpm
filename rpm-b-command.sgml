  <chapter id="ch-rpm-b-command">
    <title>&rpmb; Command Reference</title>
    <!-- label: rpm-b-command -->

    <indexterm>
      <primary>&rpmb;</primary>
    </indexterm>

    <table id="tb-rpm-b-command-">
      <title>&rpmb; Command Syntax</title>
      <tgroup cols="3">
        <colspec colnum="1" colname="option">
        <colspec colnum="2" colname="description">
        <colspec colnum="3" colname="pageref">
        <spanspec namest="option" nameend="pageref" spanname="spanall">
        <spanspec namest="option" nameend="description" spanname="span12">
        <spanspec namest="description" nameend="pageref" spanname="span23">
        <tbody>
          <row>
            <entry spanname="spanall" align="center">
              &rpmb; <command>-b<replaceable>&lt;stage&gt;</replaceable>
                <replaceable>options</replaceable> <filename>file1.spec</filename>
              &hellip; <filename>fileN.spec</filename></command>
            </entry>
          </row>
          <row>
            <entry spanname="span12" align="center">
              <replaceable>&lt;stage&gt;</replaceable>
            </entry>
            <entry>
              Page
            </entry>
          </row>
          <row>
            <entry>
              <command>p</command>
            </entry>
            <entry>
              Execute <command>%prep</command>
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-bp-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>c</command>
            </entry>
            <entry>
              Execute <command>%prep</command>, <command>%build</command>
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-bc-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>i</command>
            </entry>
            <entry>
              Execute <command>%prep</command>, <command>%build</command>,
              <command>%install</command>
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-bi-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>b</command>
            </entry>
            <entry>
              Execute <command>%prep</command>, <command>%build</command>,
              <command>%install</command>.  Package (bin)
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-bb-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>a</command>
            </entry>
            <entry>
              Execute <command>%prep</command>, <command>%build</command>,
              <command>%install</command>.  Package (bin, src)
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-ba-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>l</command>
            </entry>
            <entry>
              Check <command>%files</command> list
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-bl-option">
            </entry>
          </row>
          <row>
            <entry spanname="spanall" align="center">
              Parameters
            </entry>
          </row>
          <row>
            <entry>
              <filename>file1.spec</filename> &hellip;
              <filename>fileN.spec</filename>
            </entry>
            <entry spanname="span23" align="center">
              One or more <filename>.spec</filename> files
            </entry>
          </row>
          <row>
            <entry spanname="span12" align="center">
              Build-specific Options
            </entry>
            <entry>
              Page
            </entry>
          </row>
          <row>
            <entry>
              <command>--short-circuit</command>
            </entry>
            <entry>
              Force build to start at particular stage (<command>-bc</command>,
              <command>-bi</command> only)
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-short-circuit-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--test</command>
            </entry>
            <entry>
              Create, save build scripts for review
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-test-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--clean</command>
            </entry>
            <entry>
              Clean up after build
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-clean-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--sign</command>
            </entry>
            <entry>
              Add a digital signature to the package
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-sign-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--buildroot <replaceable>&lt;root&gt;</replaceable></command>
            </entry>
            <entry>
              Execute <command>%install</command> using
              <command><replaceable>&lt;root&gt;</replaceable></command> as the root
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-buildroot-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--buildarch <replaceable>&lt;arch&gt;</replaceable></command>
            </entry>
            <entry>
              Perform build for the
              <command><replaceable>&lt;arch&gt;</replaceable></command>
              architecture
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-buildarch-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--buildos <replaceable>&lt;os&gt;</replaceable></command>
            </entry>
            <entry>
              Perform build for the
              <command><replaceable>&lt;os&gt;</replaceable></command> operating
              system
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-buildos-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--timecheck <replaceable>&lt;secs&gt;</replaceable></command>
            </entry>
            <entry>
              Print a warning if files are over
              <command><replaceable>&lt;secs&gt;</replaceable></command> old
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-timecheck-option">
            </entry>
          </row>
          <row>
            <entry spanname="span12" align="center">
              General Options
            </entry>
            <entry>
              Page
            </entry>
          </row>
          <row>
            <entry>
              <command>-vv</command>
            </entry>
            <entry>
              Display debugging information
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-vv-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--quiet</command>
            </entry>
            <entry>
              Produce as little output as possible
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-quiet-option">
            </entry>
          </row>
          <row>
            <entry>
              <command>--rcfile <replaceable>&lt;rcfile&gt;</replaceable></command>
            </entry>
            <entry>
              Set alternate <filename>rpmrc</filename> file to
              <command><replaceable>&lt;rcfile&gt;</replaceable></command>
            </entry>
            <entry>
              <xref linkend="s2-rpm-b-command-rcfile-option">
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>


    <sect1 id="s1-rpm-b-command-what-it-does">
      <title>&rpmb; &mdash; What Does it Do?</title>
      <indexterm>
        <primary>&rpmb;</primary>
        <secondary>what it does</secondary>
      </indexterm>

      <para>
        When RPM is invoked with the <command>-b</command> option, the process
        of building a package is started.  The rest of the command will
        determine exactly what is to be built and how far the build should
        proceed.  In this chapter, we'll explore every aspect of <command>rpm
        -b</command>.
      </para>
      <para>
        An RPM build command must have two additional pieces of information,
        over and above "&rpmb;":

        <orderedlist>
          <listitem>
            <para>
              The names of one or more spec files representing software to be
              packaged.
            </para>
          </listitem>

          <listitem>
            <para>
              The desired stage at which the build is to stop.
            </para>
          </listitem>
        </orderedlist>
      </para>
      <para>
        As we discussed in <xref linkend="ch-rpm-basics">, the spec file is one
        of the inputs to RPM's build process.  It contains the information
        necessary for RPM to perform the build and package the software.
      </para>

      <para>
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
        </indexterm>
        There are a number of stages that RPM goes through during a build.  By
        specifying that the build process is to stop at a certain stage, the
        package builder can monitor the build's progress, make any changes
        necessary, and restart the build.  Let's start by looking at the various
        stages that can be specified in a build command.
      </para>

      <sect2 id="s2-rpm-b-command-bp-option">
        <title>
          &rpmb; <command>-bp</command> &mdash; Execute <command>%prep</command>
          </title>
        <!-- label: build-bp -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>p</command></tertiary>
        </indexterm>

        <para>
          The command &rpmb; <command>-bp</command> directs RPM to execute the very
          first step in the build process.  In the spec file, this step is
          labeled <command>%prep</command>.  Every command in the
          <command>%prep</command> section will be executed when the
          <command>-bp</command> option is used.
        </para>
        <para>
          Here's a simple <command>%prep</command> section from the spec file we
          used in <xref linkend="ch-rpm-build">:

          <screen width="60">
<computeroutput>
%prep
%setup
</computeroutput>
          </screen>
        </para>
        <para>
          This <command>%prep</command> section consists of a single
          <command>%setup</command> macro.  When using <command>rpm
          -bp</command> against this spec file, we can see exactly what
          <command>%setup</command> does:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bp cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
+ umask 022
+ echo Executing: %prep
Executing: %prep
+ cd /usr/src/redhat/BUILD
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz
+ tar -xvvf -
drwxrwxr-x root/users        0 Aug  4 22:30 1996 cdplayer-1.0/
-rw-r--r-- root/users    17982 Nov 10 01:10 1995 cdplayer-1.0/COPYING
-rw-r--r-- root/users      627 Nov 10 01:10 1995 cdplayer-1.0/ChangeLog
&hellip;
-rw-r--r-- root/users     2806 Nov 10 01:10 1995 cdplayer-1.0/volume.c
-rw-r--r-- root/users     1515 Nov 10 01:10 1995 cdplayer-1.0/volume.h
+ [ 0 -ne 0 ]
+ cd cdplayer-1.0
+ cd /usr/src/redhat/BUILD/cdplayer-1.0
+ chown -R root.root .
+ chmod -R a+rX,g-w,o-w .
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          First, RPM confirms that the <filename>cdplayer</filename> package is
          the subject of this build.  Then it sets the umask and starts
          executing the <command>%prep</command> section.  At this point, the
          <command>%setup</command> macro is doing its thing.  It changes
          directory into the build area and removes any old copies of
          <filename>cdplayer</filename>'s build tree.
        </para>
        <para>
          Next, <command>%setup</command> unzips the sources and uses
          <command>tar</command> to create the build tree.  We've removed the
          complete listing of files, but be prepared to see
          <emphasis>lots</emphasis> of output if the software being packaged is
          large.
        </para>
        <para>
          Finally, <command>%setup</command> changes directory into
          <filename>cdplayer</filename>'s build tree and changes ownership and
          file permissions appropriately.  The <computeroutput>exit
          0</computeroutput> signifies the end of the <command>%prep</command>
          section, and therefore, the end of the <command>%setup</command>
          macro.  Since we used the <command>-bp</command> option, RPM stopped
          at this point.  Let's see what RPM left in the build area:

          <screen width="60">
<prompt># </prompt><command>cd /usr/src/redhat/BUILD</command>
<prompt># </prompt><command>ls -l</command>
<computeroutput>
total 1
drwxr-xr-x   2 root     root         1024 Aug  4 22:30 cdplayer-1.0
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          There's the top-level directory.  Changing directory into
          <filename>cdplayer-1.0</filename>, we find the sources are ready to be
          built:

          <screen width="60">
<prompt># </prompt><command>cd cdplayer-1.0</command>
<prompt># </prompt><command>ls -lF</command>
<computeroutput>
total 216
-rw-r--r--   1 root     root        17982 Nov 10  1995 COPYING
-rw-r--r--   1 root     root          627 Nov 10  1995 ChangeLog
&hellip;
-rw-r--r--   1 root     root         2806 Nov 10  1995 volume.c
-rw-r--r--   1 root     root         1515 Nov 10  1995 volume.h
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          We can see that <command>%setup</command>'s <command>chown</command>
          and <command>chmod</command> commands did what they were supposed to
          &mdash; the files are owned by root, with permissions set
          appropriately.
        </para>
        <para>
          If not stopped by the <command>-bp</command> option, the next step in
          RPM's build process would be to build the software.  RPM can also be
          stopped at the end of the <command>%build</command> section in the
          spec file.  This is done by using the <command>-bc</command> option:
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-bc-option">
        <title>
          &rpmb; <command>-bc</command> &mdash; Execute <command>%prep</command>,
          <command>%build</command>
        </title>
        <!-- label: build-bc -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>c</command></tertiary>
        </indexterm>

        <para>
          When the <command>-bc</command> option is used during a build, RPM
          stops once the software has been built.  In terms of the spec file,
          every command in the <command>%build</command> section will be
          executed.  In the following example, we've removed the output from the
          <command>%prep</command> section to cut down on the redundant output,
          but keep in mind that it is executed nonetheless:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bc cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make
gcc -Wall -O2  -c -I/usr/include/ncurses  cdp.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  color.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  display.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  misc.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  volume.c 
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
gcc -Wall -O2  -c -I/usr/include/ncurses  hardware.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  database.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  getline.c 
gcc -o cdp cdp.o color.o display.o misc.o volume.o hardware.o database.o
getline.o  -I/usr/include/ncurses  -L/usr/lib -lncurses
groff -Tascii -man cdp.1 | compress &gt;cdp.1.Z
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          After the command, we see RPM executing the <command>%prep</command>
          section (which we've removed almost entirely).  Next, RPM starts
          executing the contents of the <command>%build</command> section.  In
          our example spec file, the <command>%build</command> section looks
          like this:

          <screen width="60">
<computeroutput>
%build
make 
</computeroutput>
          </screen>
        </para>
        <para>
          We see that prior to the <command>make</command> command, RPM changes
          directory into <filename>cdplayer</filename>'s top-level directory.
          RPM then starts the <command>make</command>, which ends with the
          <command>groff</command> command.  At this point, the execution of the
          <command>%build</command> section has been completed.  Since the
          <command>-bc</command> option was used, RPM stops at this point.
        </para>
        <para>
          The next step in the build process would be to install the newly built
          software.  This is done in the <command>%install</command> section of
          the spec file.  RPM can be stopped after the install has taken place
          by using the <command>-bi</command> option:
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-bi-option">
        <title>
          &rpmb; <command>-bi</command> &mdash; Execute <command>%prep</command>,
          <command>%build</command>, <command>%install</command>
        </title>
        <!-- label: build-bi -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>i</command></tertiary>
        </indexterm>

        <para>
          By using the <command>-bi</command> option, RPM is directed to stop
          once the software is completely built and installed on the build
          system.  Here's what the output of a build using the
          <command>-bi</command> option looks like:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bi cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make install
chmod 755 cdp
chmod 644 cdp.1.Z
cp cdp /usr/local/bin
ln -s /usr/local/bin/cdp /usr/local/bin/cdplay
cp cdp.1 /usr/local/man/man1
+ exit 0
+ umask 022
+ echo Executing: special doc
Executing: special doc
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ DOCDIR=//usr/doc/cdplayer-1.0-1
+ rm -rf //usr/doc/cdplayer-1.0-1
+ mkdir -p //usr/doc/cdplayer-1.0-1
+ cp -ar README //usr/doc/cdplayer-1.0-1
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          As before, we've excised most of the previously described sections.
          In this example, the <command>%install</command> section looks like:

          <screen width="60">
<computeroutput>
%install
make install
</computeroutput>
          </screen>
        </para>
        <para>
          After the <command>%prep</command> and <command>%build</command>
          sections, the <command>%install</command> section is executed.
          Looking at the output, we see that RPM changes directory into
          <filename>cdplayer</filename>'s top-level directory and issues the
          <command>make install</command> command, the sole command in the
          <command>%install</command> section.  The output from that point until
          the first <computeroutput>exit 0</computeroutput>, is from
          <command>make install</command>.
        </para>
        <para>
          The remaining commands are due to the contents of the spec file's
          <command>%files</command> list.  Here's what it looks like:

          <screen width="60">
<computeroutput>
%files
%doc README
/usr/local/bin/cdp
/usr/local/bin/cdplay
/usr/local/man/man1/cdp.1
</computeroutput>
          </screen>
        </para>
        <para>
          The line responsible is <command>%doc README</command>.  The
          <command>%doc</command> tag identifies the file as being
          documentation.  RPM handles documentation files by creating a
          directory in <filename>/usr/doc</filename> and placing all
          documentation in it.  The <computeroutput>exit 0</computeroutput> at
          the end signifies the end of the <command>%install</command> section.
          RPM stops due to the <command>-bi</command> option.
        </para>
        <para>
          The next step at which RPM's build process can be stopped is after the
          software's binary package file has been created.  This is done using
          the <command>-bb</command> option:
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-bb-option">
        <title>
          &rpmb; <command>-bb</command> &mdash; Execute <command>%prep</command>,
          <command>%build</command>, <command>%install</command>, package
          (bin)
        </title>
        <!-- label: build-bb -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>b</command></tertiary>
        </indexterm>

        <screen width="60">
<prompt># </prompt>&rpmb; <command>-bb cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
usr/doc/cdplayer-1.0-1
usr/doc/cdplayer-1.0-1/README
usr/local/bin/cdp
usr/local/bin/cdplay
usr/local/man/man1/cdp.1
93 blocks
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
+ umask 022
+ echo Executing: %clean
Executing: %clean
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ exit 0
</computeroutput>
<prompt># </prompt>
        </screen>

        <para>
          After executing the <command>%prep</command>,
          <command>%build</command>, and <command>%install</command> sections,
          and handling any special documentation files, RPM then creates a
          binary package file.  In the sample output, we see that first RPM
          performs automatic dependency checking.  It does this by determining
          which shared libraries are required by the executable programs
          contained in the package.  Next, RPM actually archives the files to be
          packaged, optionally signs the package file, and outputs the finished
          product.
        </para>
        <para>
          The last part of RPM's output looks suspiciously like a section in the
          spec file being executed.  In our example, there is no
          <command>%clean</command> section.  If there were, however, RPM would
          have executed any commands in the section.  In the absence of a
          <command>%clean</command> section, RPM simply issues the usual
          <command>cd</command> commands and exits normally.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-ba-option">
        <title>
          &rpmb; <command>-ba</command> &mdash; Execute <command>%prep</command>,
          <command>%build</command>, <command>%install</command>, package
          (bin, src)
        </title>
        <!-- label: build-ba -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>a</command></tertiary>
        </indexterm>

        <para>
          The <command>-ba</command> option directs RPM to perform
          <emphasis>all</emphasis> the stages in building a package.  With this
          one command, RPM:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Unpacks the original sources.
              </para>
            </listitem>

            <listitem>
              <para>
                Applies patches (if desired).
              </para>
            </listitem>

            <listitem>
              <para>
                Builds the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Installs the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Creates the binary package file.
              </para>
            </listitem>

            <listitem>
              <para>
                Creates the source package file.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          That's quite a bit of work for one command!  Here it is, in action:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
&hellip;
Executing: %clean
&hellip;
+ exit 0
Source Packaging: cdplayer-1.0-1
cdplayer-1.0.spec
cdplayer-1.0.tgz
80 blocks
Generating signature: 0
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          As in previous examples, RPM executes the <command>%prep</command>,
          <command>%build</command>, and <command>%install</command> sections,
          handles any special documentation files, creates a binary package
          file, and cleans up after itself.
        </para>
        <para>
          The final step in the build process is to create a source package
          file.  As the output shows, it consists of the spec file and the
          original sources.  A source package may optionally include one or more
          patch files, although in our example, <filename>cdplayer</filename>
          requires none.
        </para>
        <para>
          At the end of a build using the <command>-ba</command> option, the
          software has been successfully built and packaged in both binary and
          source form.  But there are a few more build-time options that we can
          use.  One of them is the <command>-bl</command> option:
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-bl-option">
        <title>
          &rpmb; <command>-bl</command> &mdash; Check <command>%files</command> list
        </title>
        <!-- label: build-bl -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>build stages of</secondary>
          <tertiary><command>l</command></tertiary>
        </indexterm>

        <para>
          There's one last letter that may be specified with <command>rpm
          -b</command>, but unlike the others, which indicate the stage at which
          the build process is to stop, this option performs a variety of checks
          on the <command>%files</command> list in the named spec file.  When
          <command>l</command> is added to &rpmb;, the
          following checks are performed:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Expands the spec file's <command>%files</command> list and
                checks that each file listed actually exists.
              </para>
            </listitem>

            <listitem>
              <para>
                Determines what shared libraries the software requires by
                examining every executable file listed.
              </para>
            </listitem>

            <listitem>
              <para>
                Determines what shared libraries are provided by the package.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Why is it necessary to do all this checking?  When would it be useful?
          Keep in mind that the <command>%files</command> list must be generated
          manually.  By using the <command>-bl</command> option, the following
          steps are all that's necessary to create a <command>%files</command>
          list:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Writing the <command>%files</command> list.
              </para>
            </listitem>

            <listitem>
              <para>
                Using the <command>-bl</command> option to check the
                <command>%files</command> list.
              </para>
            </listitem>

            <listitem>
              <para>
                Making any necessary changes to the <command>%files</command>
                list.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          It may take more than one iteration through these steps, but
          eventually the list check will pass.  Using the <command>-bl</command>
          option to check the <command>%files</command> list is certainly better
          than starting a two-hour package build, only to find out at the very
          end that the list contains a misspelled filename.
        </para>
        <para>
          Here's an example of the <command>-bl</command> option in action:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bl cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          It's hard to see exactly what RPM is doing from the output, but if we
          add <command>-vv</command>, we can get a bit more information:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bl -vv cdplayer-1.0.spec</command>
<computeroutput>
D: Switched to BASE package
D: Source(0) = sunsite.unc.edu:/pub/Linux/apps/sound/cds/cdplayer-1.0.tgz
D: Switching to part: 12
D: fileFile = 
D: Switched to package: (null)
D: Switching to part: 2
D: fileFile = 
D: Switching to part: 3
D: fileFile = 
D: Switching to part: 4
D: fileFile = 
D: Switching to part: 10
D: fileFile = 
D: Switched to package: (null)
* Package: cdplayer
File List Check: cdplayer-1.0-1
D: ADDING: /usr/doc/cdplayer-1.0-1
D: ADDING: /usr/doc/cdplayer-1.0-1/README
D: ADDING: /usr/local/bin/cdp
D: ADDING: /usr/local/bin/cdplay
D: ADDING: /usr/local/man/man1/cdp.1
D: md5(/usr/doc/cdplayer-1.0-1/README) = 2c149b2fb1a4d65418131a19b242601c
D: md5(/usr/local/bin/cdp) = 0f2a7a2f81812c75fd01c52f456798d6
D: md5(/usr/local/bin/cdplay) = d41d8cd98f00b204e9800998ecf8427e
D: md5(/usr/local/man/man1/cdp.1) = b32cc867ae50e2bdfa4d6780b084adfa
Finding dependencies...
D: Adding require: libncurses.so.2.0
D: Adding require: libc.so.5
Requires (2): libc.so.5 libncurses.so.2.0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          Looking at this more verbose output, it's easy to see there's a great
          deal going on.  Some of it is not directly pertinent to checking the
          <command>%files</command> list, however.  For example, the output
          extending from the first line, to the line reading <computeroutput>*
          Package: cdplayer</computeroutput>, reflects processing that takes
          place during actual package building, and can be ignored.
        </para>
        <para>
          Following that section is the actual <command>%files</command> list
          check.  In this section, every file named in the
          <command>%files</command> list is checked to make sure it exists.  The
          phrase, <computeroutput>ADDING:</computeroutput>, again reflects RPM's
          package building roots.  When using the <command>-bl</command> option,
          however, RPM is simply making sure the files exist on the build
          system.  If the <command>--timecheck</command> option (described a bit
          later, on <xref linkend="s2-rpm-b-command-timecheck-option">) is
          present, the checks required by that option are performed here, as
          well.
        </para>
        <para>
          After the list check, the MD5 checksums of each file are calculated
          and displayed.  While this information is vital during actual package
          building, it is not used when using the <command>-bl</command> option.
        </para>
        <para>
          Finally, RPM determines which shared libraries the listed files
          require.  In this case, there are only two &mdash;
          <filename>libc.so.5</filename>, and
          <filename>libncurses.so.2.0</filename>.  While not strictly a part of
          the list-checking process, displaying shared library dependencies can
          be quite helpful at this point.  It can point out possible problems,
          such as assuming that the target systems have a certain library
          installed when, in fact, they do not.
        </para>
        <para>
          So far, we've only seen what happens when the
          <command>%files</command> list is correct.  Let's see what happens
          where the list has problems.  In this example, we've added a bogus
          file to the package's <command>%files</command> list:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bl cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
File not found: /usr/local/bin/bogus
Build failed.
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          Reflecting more of its package building roots, <command>rpm
          -bl</command> says that the "build failed".  But the bottom line is
          that there is no such file as <filename>/usr/bin/bogus</filename>.  In
          this example we made the name obviously wrong, but in a more
          real-world setting, the name will more likely be a misspelling in the
          <command>%files</command> list.  OK, let's correct the
          <command>%files</command> list and try again:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bl cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
File not found: /usr/local/bin/cdplay
Build failed.
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          Another error!  In this case the file is spelled correctly, but it is
          not on the build system, even though it should be.  Perhaps it was
          deleted accidentally.  In any case, let's rebuild the software and try
          again:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bi cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
ln -s /usr/local/bin/cdp /usr/local/bin/cdplay
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
</computeroutput>
<prompt># </prompt>
<prompt># </prompt>&rpmb; <command>-bl cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          Done!  The moral to this story is that using <command>rpm
          -bl</command> and fixing the error it flagged doesn't necessarily mean
          your <command>%files</command> list is ready for prime-time: Always
          run it again to make sure!
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-short-circuit-option">
        <title>
          <command>--short-circuit</command> &mdash; Force build to start at
          particular stage
        </title>
        <!-- label: build- -short-circuit -->
        <indexterm>
          <primary>&rpmb;</primary>
          <secondary>options</secondary>
        </indexterm>
        <indexterm>
          <primary><command>--short-circuit</command> option</primary>
        </indexterm>

        <para>
          Although it sounds dangerous, the <command>--short-circuit</command>
          option can be your friend.  This option is used during the initial
          development of a package.  Earlier in the chapter, we explored
          stopping RPM's build process at different stages.  Using
          <command>--short-circuit</command>, we can <emphasis>start</emphasis>
          the build process at different stages.
        </para>
        <para>
          One time that <command>--short-circuit</command> comes in handy is
          when you're trying to get software to build properly.  Just think what
          it would be like &mdash; you're hacking away at the sources, trying a
          build, getting an error, and hacking some more to fix that error.
          Without <command>--short-circuit</command>, you'd have to:

          <orderedlist>
            <listitem>
              <para>
                Make your change to the sources.
              </para>
            </listitem>

            <listitem>
              <para>
                Use <command>tar</command> to create a new source archive.
              </para>
            </listitem>

            <listitem>
              <para>
                Start a build with something like &rpmb; <command>-bc</command>.
              </para>
            </listitem>

            <listitem>
              <para>
                See another bug.
              </para>
            </listitem>

            <listitem>
              <para>
                Go back to step 1.
              </para>
            </listitem>
          </orderedlist>
        </para>
        <para>
          Pretty cumbersome!  Since RPM's build process is designed to start
          with the sources in their original <command>tar</command> file, unless
          your modifications end up in that <command>tar</command> file, they
          won't be used in the next build.
          <footnote>
            <para>
              As we mentioned in <xref linkend="ch-rpm-basics">, if the original
              sources need to be modified, the modifications should be kept as a
              separate set of patches.  However, during development, it makes
              more sense to not generate patches every time a change to the
              original source is made.
            </para>
          </footnote>
        </para>
        <para>
          But there's another way.  Just follow these steps:

          <orderedlist>
            <listitem>
              <para>
                Place the original source <command>tar</command> file in RPM's
                <filename>SOURCES</filename> directory.
              </para>
            </listitem>

            <listitem>
              <para>
                Create a partial spec file in RPM's <filename>SPECS</filename>
                directory (Be sure to include a valid <command>Source</command>
                line).
              </para>
            </listitem>

            <listitem>
              <para>
                Issue an &rpmb; <command>-bp</command> to properly create the build
                environment.
              </para>
            </listitem>
          </orderedlist>
        </para>
        <para>
          Now use <command>--short-circuit</command> to attempt a compile.
          Here's an example:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bc --short-circuit cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
+ umask 022
+ echo Executing: %build
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make
gcc -Wall -O2  -c -I/usr/include/ncurses  cdp.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  color.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  display.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  misc.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  volume.c 
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
gcc -Wall -O2  -c -I/usr/include/ncurses  hardware.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  database.c 
gcc -Wall -O2  -c -I/usr/include/ncurses  getline.c 
gcc -o cdp cdp.o color.o display.o misc.o volume.o
     hardware.o database.o getline.o  -I/usr/include/ncurses
     -L/usr/lib -lncurses
groff -Tascii -man cdp.1 | compress &gt;cdp.1.Z
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          Normally, the <command>-bc</command> option instructs RPM to
          <emphasis>stop</emphasis> the build after the
          <command>%build</command> section of the spec file has been executed.
          By adding <command>--short-circuit</command>, however, RPM
          <emphasis>starts</emphasis> the build by executing the
          <command>%build</command> section and stops when everything in
          <command>%build</command> has been executed.
        </para>
        <para>
          There is only one other build stage that can be
          <command>--short-circuit</command>'ed, and that is the install stage.
          The reason for this restriction is to make it difficult to bypass
          RPM's use of pristine sources.  If it were possible to
          <command>--short-circuit</command> to <command>-bb</command> or
          <command>-ba</command>, a package builder might take the "easy" way
          out and simply hack at the build tree until the software built
          successfully, then package the hacked sources.  So, RPM will only
          <command>--short-circuit</command> to <command>-bc</command> or
          <command>-bi</command>.  Nothing else will do.
        </para>
        <para>
          What exactly does an &rpmb; <command>-bi --short-circuit</command> do,
          anyway?  Like an &rpmb; <command>-bc --short-circuit</command>, it starts
          executing at the named stage, which in this case is
          <command>%install</command>.  Note that the build environment must be
          ready to perform an install before attempting to
          <command>--short-circuit</command> to the <command>%install</command>
          stage.  If the software installs via <command>make install</command>,
          <command>make</command> will automatically compile the software
          anyway.
        </para>
        <para>
          And what happens if the build environment isn't ready and a
          <command>--short-circuit</command> is attempted?  Let's see:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bi --short-circuit cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
+ umask 022
+ echo Executing: %install
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
/var/tmp/rpmbu01157aaa: cdplayer-1.0: No such file or directory
Bad exit status
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          RPM blindly started executing the <command>%install</command> stage,
          but came to an abrupt halt when it attempted to change directory into
          <filename>cdplayer-1.0</filename>, which didn't exist.  After giving a
          descriptive error message, RPM exited with a failure status.  Except
          for some minor differences, &rpmb; <command>-bc</command> would have
          failed in the same way.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-buildarch-option">
        <title>
          <command>--buildarch <replaceable>&lt;arch&gt;</replaceable></command>
          &mdash; Perform Build For the
          <command><replaceable>&lt;arch&gt;</replaceable></command>
          Architecture
        </title>
        <!-- label: build- -buildarch -->
        <indexterm>
          <primary><command>--buildarch</command> option</primary>
        </indexterm>

        <para>
          The <command>--buildarch</command> option is used to override RPM's
          architecture detection logic.  The option is followed by the desired
          architecture name.  Here's an example:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --buildarch i486 cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/RPMS/i486/cdplayer-1.0-1.i486.rpm
&hellip;
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          We've removed most of RPM's output from this example, but the main
          thing we can see from this example is that the package was built for
          the <filename>i486</filename> architecture, due to the inclusion of
          the <command>--buildarch</command> option on the command line.  We can
          also see that RPM wrote the binary package in the
          architecture-specific directory,
          <filename>/usr/src/redhat/RPMS/i486</filename>.  Using RPM's
          <command>--queryformat</command> option confirms the package's
          architecture:

          <screen width="60">
<prompt># </prompt>&rpmq; <command>-qp --queryformat '%{arch}\n' /usr/src/redhat/RPMS/i486/cdplayer-1.0-1.i486.rpm</command>
<computeroutput>
i486
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          For more information on build packages for multiple architectures,
          please see <xref linkend="ch-rpm-multi">.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-buildos-option">
        <title>
          <command>--buildos <replaceable>&lt;os&gt;</replaceable></command>
          &mdash; Perform Build For the
          <command><replaceable>&lt;os&gt;</replaceable></command> Operating
          System
        </title>
        <!-- label: build- -buildos -->
        <indexterm>
          <primary><command>--buildos</command> option</primary>
        </indexterm>

        <para>
          The <command>--buildos</command> option is used to override RPM's
          operating system detection logic.  The option is followed by the
          desired operating system name.  Here's an example:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --buildos osf1 cdplayer-1.0.spec</command>
<computeroutput>
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
Source Packaging: cdplayer-1.0-1
&hellip;
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          There's nothing in the build output that explicitly states the build
          operating system as been set to <command>osf1</command>.  Let's see if
          <command>--queryformat</command> will tell us:

          <screen width="60">
<prompt># </prompt>&rpmq; <command>-qp --queryformat '%{os}\n' /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm</command>
<computeroutput>
osf1
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          The package was indeed built for the specified operating system.  For
          more information on building packages for multiple operating systems,
          please see <xref linkend="ch-rpm-multi">.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-sign-option">
        <title>
          <command>--sign</command> &mdash; Add a Digital Signature to the
          Package
        </title>
        <!-- label: build- -sign -->
        <indexterm>
          <primary><command>--sign</command> option</primary>
        </indexterm>

        <para>
          The <command>--sign</command> option directs RPM to add a digital
          signature to the package being built.  Currently, this is done using
          PGP.  Here's an example of <command>--sign</command> in action:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --sign cdplayer-1.0.spec</command>
<computeroutput>
Enter pass phrase: <userinput>passphrase</userinput> (not echoed)
Pass phrase is good.
* Package: cdplayer
&hellip;
Binary Packaging: cdplayer-1.0-1
&hellip;
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
&hellip;
Source Packaging: cdplayer-1.0-1
&hellip;
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          The most obvious effect of adding the <command>--sign</command> option
          to a build command is that RPM then asks for your private key's
          passphrase.  After entering the passphrase (which isn't echoed), the
          build proceeds as usual.  The only other difference between this and a
          non-signed build is that the <computeroutput>Generating
          signature:</computeroutput> lines have a non-zero value.
        </para>
        <para>
          Let's check the source and binary packages we've just created and see
          if they are, in fact, signed:

          <screen width="60">
<prompt># </prompt>&rpmk; <command>--checksig /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm</command>
<computeroutput>
/usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm: size pgp md5 OK
</computeroutput>
<prompt># </prompt>&rpmk; <command>--checksig /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm</command>
<computeroutput>
/usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm: size pgp md5 OK
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          The fact that there is a <command>pgp</command> in
          <command>--checksig</command>'s output indicates that the packages
          have been signed.
        </para>
        <para>
          For more information on signing packages, please see <xref
          linkend="ch-rpm-pgp">.  Also, <xref linkend="ch-pgp-intro">
          contains information on obtaining and installing PGP.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-test-option">
        <title>
          <command>--test</command> &mdash; Create, Save Build Scripts For
          Review
        </title>
        <!-- label: build- -test -->
        <indexterm>
          <primary><command>--test</command> option</primary>
        </indexterm>

        <para>
          There are times when it might be necessary to get a more in-depth view
          of a particular build.  By using the <command>--test</command> option,
          it's easy.  When <command>--test</command> is added to a build
          command, the scripts RPM would normally use to actually perform the
          build, are created and saved for you to review.  Let's see how it
          works:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --test cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          Unlike a normal build, there's not much output.  But the
          <command>--test</command> option has caused a set of scripts to be
          written and saved for you.  The question is: Where are they?
        </para>
        <para>
          If you are using a customized <filename>rpmrc</filename> file, the
          scripts will be written to the directory specified by the
          <filename>rpmrc</filename> entry <command>tmppath</command>.  If you
          haven't changed this setting, RPM, by default, writes the scripts in
          <filename>/var/tmp</filename>.  Here they are:

          <screen width="60">
<prompt># </prompt><command>ls -l /var/tmp</command>
<computeroutput>
total 4
-rw-rw-r--   1 root     root          670 Sep 17 20:35 rpmbu00236aaa
-rw-rw-r--   1 root     root          449 Sep 17 20:35 rpmbu00236baa
-rw-rw-r--   1 root     root          482 Sep 17 20:35 rpmbu00236caa
-rw-rw-r--   1 root     root          552 Sep 17 20:35 rpmbu00236daa
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          Each file contains a script that performs a given part of the build.
          Here's the first file:

          <screen width="60">
<computeroutput>
#!/bin/sh -e
# Script generated by rpm

RPM_SOURCE_DIR="/usr/src/redhat/SOURCES"
RPM_BUILD_DIR="/usr/src/redhat/BUILD"
RPM_DOC_DIR="/usr/doc"
RPM_OPT_FLAGS="-O2 -m486 -fno-strength-reduce"
RPM_ARCH="i386"
RPM_OS="Linux"
RPM_ROOT_DIR="/tmp/cdplayer"
RPM_BUILD_ROOT="/tmp/cdplayer"
RPM_PACKAGE_NAME="cdplayer"
RPM_PACKAGE_VERSION="1.0"
RPM_PACKAGE_RELEASE="1"
set -x

umask 022

echo Executing: %prep
cd /usr/src/redhat/BUILD

cd /usr/src/redhat/BUILD
rm -rf cdplayer-1.0
gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz | tar -xvvf -
if [ $? -ne 0 ]; then
  exit $?
fi
cd cdplayer-1.0
cd /usr/src/redhat/BUILD/cdplayer-1.0
chown -R root.root .
chmod -R a+rX,g-w,o-w .
</computeroutput>
          </screen>
        </para>
        <para>
          As we can see, this script contains the <command>%prep</command>
          section from the spec file.  The script starts off by defining a
          number of environment variables and then leads into the
          <command>%prep</command> section.  In the spec file used in this
          build, the <command>%prep</command> section consists of a single
          <command>%setup</command> macro.  In this file, we can see exactly how
          RPM expands that macro.  The remaining files follow the same basic
          layout &mdash; a section defining environment variables, followed by
          the commands to be executed.
        </para>
        <para>
          Note that the <command>--test</command> option will only create script
          files for each build stage, as specified in the command line.  For
          example, if the above command was changed to:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bp --test cdplayer-1.0.spec</command>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          only one script file, containing the <command>%prep</command>
          commands, would be written.  In any case, no matter what RPM build
          command is used, the <command>--test</command> option can let you see
          exactly what is going to happen during a build.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-clean-option">
        <title><command>--clean</command> &mdash; Clean up after build</title>
        <!-- label: build- -clean -->
        <indexterm>
          <primary><command>--clean</command> option</primary>
        </indexterm>

        <para>
          The <command>--clean</command> option can be used to ensure that the
          package's build directory tree is removed at the end of a build.
          Although it can be used with any build stage, it doesn't always make
          much sense to do so:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bp --clean cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
+ echo Executing: sweep
Executing: sweep
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          In this example, we see a typical <command>%prep</command> section
          being executed.  The line "<computeroutput>+ echo Executing:
          sweep</computeroutput>" indicates the start of
          <command>--clean</command>'s activity.  After changing directory into
          the build directory, RPM then issues a recursive delete on the
          package's top-level directory.
        </para>
        <para>
          As we noted above, this particular example doesn't make much sense.
          We're only executing the <command>%prep</command> section, which
          creates the package's build tree, and using
          <command>--clean</command>, which removes it!  Using
          <command>--clean</command> with the <command>-bc</command> option
          isn't very productive either, as the newly built software remains in
          the build tree.  Once again, there would be no remnants left after
          <command>--clean</command> has done its thing.
        </para>
        <para>
          Normally, the <command>--clean</command> option is used once the
          software builds and can be packaged successfully.  It is particularly
          useful when more than one package is to be built, since
          <command>--clean</command> ensures that the filesystem holding the
          build area will not fill up with build trees from each package.
        </para>
        <para>
          Note also that the <command>--clean</command> option only removes the
          files that reside in the software's build tree.  If there are any
          files that the build creates outside of this hierarchy, it will be
          necessary to write a script for the spec file's
          <command>%clean</command> section.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-buildroot-option">
        <title>
          <command>--buildroot <replaceable>&lt;path&gt;</replaceable></command>
          &mdash; Execute <command>%install</command> using
          <command><replaceable>&lt;path&gt;</replaceable></command> as the root
        </title>
        <!-- label: build- -buildroot -->
        <indexterm>
          <primary><command>--buildroot</command> option</primary>
        </indexterm>

        <para>
          The <command>--buildroot</command> option can make two difficult
          situations much easier:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Performing a build without impacting the build system.
              </para>
            </listitem>

            <listitem>
              <para>
                Allowing non-root users to build packages.
              </para>
            </listitem>
          </itemizedlist>
        </para>

        <para>
          Let's study the first situation in a bit more detail.  Say, for
          example, that <application>sendmail</application> is to be packaged.
          In the course of creating a <application>sendmail</application>
          package, the software must be installed.  This would mean that
          critical <application>sendmail</application> files, such as
          <filename>sendmail.cf</filename> and <filename>aliases</filename>,
          would be overwritten.  Mail handling on the build system would almost
          certainly be disrupted.
        </para>
        <para>
          In the second case, it's certainly possible to set permissions such
          that non-root users can install software, but highly unlikely that any
          system administrator worth their salt would do so.  What can be done
          to make these situations more tenable?
        </para>
        <para>
          The <command>--buildroot</command> option is used to instruct RPM to
          use a directory other than <filename>/</filename> as a "build root".
          This phrase is a bit misleading, in that the build root is
          <emphasis>not</emphasis> the root directory under which the software
          is built.  Rather, it is the root directory for the install phase of
          the build.  When a build root is not specified, the software being
          packaged is installed relative to the build system's root directory
          "<filename>/</filename>".
        </para>
        <para>
          However, it's not enough to just specify a build root on the command
          line.  The spec file for the package must be set up to support a build
          root.  If you don't make the necessary changes, this is what you'll
          see:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --buildroot /tmp/foo cdplayer-1.0.spec</command>
<computeroutput>
Package can not do build prefixes
Build failed.
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          <xref linkend="ch-rpm-anywhere"> has complete instructions on
          the modifications necessary to configure a package to use an alternate
          build root, as well as methods to permit users to build packages
          without root access.  Assuming that the necessary modifications have
          been made, here is what the build would look like:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --buildroot /tmp/foonly cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
Executing: %prep
+ cd /usr/src/redhat/BUILD
&hellip;
+ exit 0
Executing: %build
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
&hellip;
+ exit 0
+ umask 022
Executing: %install
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ make ROOT=/tmp/foonly install
install -m 755 -o 0 -g 0 -d /tmp/foonly/usr/local/bin/
install -m 755 -o 0 -g 0 cdp /tmp/foonly/usr/local/bin/cdp
rm -f /tmp/foonly/usr/local/bin/cdplay
ln -s /tmp/foonly/usr/local/bin/cdp /tmp/foonly/usr/local/bin/cdplay
install -m 755 -o 0 -g 0 -d /tmp/foonly/usr/local/man/man1/
install -m 755 -o 0 -g 0 cdp.1 /tmp/foonly/usr/local/man/man1/cdp.1
+ exit 0
Executing: special doc
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ DOCDIR=/tmp/foonly//usr/doc/cdplayer-1.0-1
+ rm -rf /tmp/foonly//usr/doc/cdplayer-1.0-1
+ mkdir -p /tmp/foonly//usr/doc/cdplayer-1.0-1
+ cp -ar README /tmp/foonly//usr/doc/cdplayer-1.0-1
+ exit 0
Binary Packaging: cdplayer-1.0-1
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
usr/doc/cdplayer-1.0-1
usr/doc/cdplayer-1.0-1/README
usr/local/bin/cdp
usr/local/bin/cdplay
usr/local/man/man1/cdp.1
93 blocks
Generating signature: 0
Wrote: /usr/src/redhat/RPMS/i386/cdplayer-1.0-1.i386.rpm
+ umask 022
+ echo Executing: %clean
Executing: %clean
+ cd /usr/src/redhat/BUILD
+ cd cdplayer-1.0
+ exit 0
Source Packaging: cdplayer-1.0-1
cdplayer-1.0.spec
cdplayer-1.0.tgz
82 blocks
Generating signature: 0
Wrote: /usr/src/redhat/SRPMS/cdplayer-1.0-1.src.rpm
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          As the somewhat edited output shows, the <command>%prep</command>,
          <command>%build</command>, and <command>%install</command> sections
          are executed in RPM's normal build directory.  However, the
          <command>--buildroot</command> option comes into play when the
          <command>make install</command> is done.  As we can see, the
          <envar>ROOT</envar> variable is set to
          <filename>/tmp/foonly</filename>, which was the value following
          <command>--buildroot</command> on the command line.  From that point
          on, we can see that <command>make</command> substituted the new build
          root value during the install phase.
        </para>
        <para>
          The build root is also used when documentation files are installed.
          The documentation directory <filename>cdplayer-1.0-1</filename> is
          created in <filename>/tmp/foonly/usr/doc</filename>, and the
          <filename>README</filename> file is placed in it.
        </para>
        <para>
          The only remaining difference that results from using
          <command>--buildroot</command>, is that the files to be included in
          the binary package are not located relative to the build system's root
          directory.  Instead they are located relative to the build root
          <filename>/tmp/foonly</filename>.  The resulting binary and source
          package files are functionally equivalent to packages built without
          the use of <command>--buildroot</command>.
        </para>

        <sect3 id="s3-rpm-b-command-buildroot-warning">
          <title>Using <command>--buildroot</command> Can Bite You!</title>
          <!-- label: buildroot-bite -->
          <indexterm>
            <primary><command>--buildroot</command> option</primary>
            <secondary>warning</secondary>
          </indexterm>

          <para>
            Although the <command>--buildroot</command> option can solve some
            problems, using a build root can actually be dangerous.  How?
            Consider the following situation:

            <itemizedlist mark="bullet">
              <listitem>
                <para>
                  A spec file is configured to have a build root of
                  <filename>/tmp/blather</filename>, for instance.
                </para>
              </listitem>

              <listitem>
                <para>
                  In the <command>%prep</command> section
                  <footnote>
                    <para>
                      Or the <command>%clean</command> section, it doesn't
                      matter &mdash; the end result is the same.
                    </para>
                  </footnote>
                  , there is an <command>rm -rf $RPM_BUILD_ROOT</command>
                  command to clean out any old installed software.
                </para>
              </listitem>

              <listitem>
                <para>
                  You decide to build the software so that it installs relative
                  to your system's root directory, so you enter the following
                  command: "&rpmb; <command>-ba --buildroot / foo.spec</command>".
                </para>
              </listitem>
            </itemizedlist>
          </para>
          <para>
            The end result?  Since specifying "<filename>/</filename>" as the
            build root sets <envar>$RPM_BUILD_ROOT</envar> to
            "<filename>/</filename>", that innocuous little <command>rm -rf
            <envar>$RPM_BUILD_ROOT</envar></command> turns into <command>rm -rf
            /</command>!  A recursive delete, starting at your system's root
            directory, might not be a total disaster if you catch it quickly,
            but in either case, you'll be testing your ability to restore from
            backup&hellip; Er, you <emphasis>do</emphasis> have backups, don't
            you?
          </para>
          <para>
            The moral of this story is to be <emphasis>very</emphasis> careful
            when using <command>--buildroot</command>.  A good rule of thumb is
            to always specify a unique build root.  For example, instead of
            specifying <filename>/tmp</filename> as a build root (and possibly
            losing your system's directory for holding temporary files), use the
            path <filename>/tmp/mypackage</filename>, where the directory
            <filename>mypackage</filename> is used only by the package you're
            building.
          </para>
        </sect3>
      </sect2>

      <sect2 id="s2-rpm-b-command-timecheck-option">
        <title>
          <command>--timecheck <replaceable>&lt;secs&gt;</replaceable></command>
          &mdash; Print a warning if files to be packaged are over
          <command><replaceable>&lt;secs&gt;</replaceable></command> old
        </title>
        <!-- label: build- -timecheck -->
        <indexterm>
          <primary><command>--timecheck</command> option</primary>
        </indexterm>

        <para>
          While it's possible to detect many errors in the
          <command>%files</command> list using &rpmb; <command>-bl</command>, there
          is another type of problem that can't be detected.  Consider the
          following scenario:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                A package you're building creates the file
                <filename>/usr/bin/foo</filename>.
              </para>
            </listitem>

            <listitem>
              <para>
                Because of a problem with the package's makefile,
                <filename>foo</filename> is never copied into
                <filename>/usr/bin</filename>.
              </para>
            </listitem>

            <listitem>
              <para>
                An older, incompatible version of <filename>foo</filename>,
                created several months ago, already exists in
                <filename>/usr/bin</filename>.
              </para>
            </listitem>

            <listitem>
              <para>
                RPM creates the binary package file.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Is the incompatible <filename>/usr/bin/foo</filename> included in the
          package?  You bet it is!  If only there was some way for RPM to catch
          this type of problem&hellip;
        </para>
        <para>
          Well, there is!  By adding <command>--timecheck</command>, followed by
          a number, RPM will check each file being packaged, to see if the file
          is more than the specified number of seconds old.  If it is, a warning
          message is displayed.  The <command>--timecheck</command> option works
          with either the <command>-ba</command> or <command>-bl</command>
          options.  Here's an example using <command>-bl</command>:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bl --timecheck 3600 cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
File List Check: cdplayer-1.0-1
warning: TIMECHECK failure: /usr/doc/cdplayer-1.0-1/README
Finding dependencies...
Requires (2): libc.so.5 libncurses.so.2.0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          In this example, the file
          <filename>/usr/doc/cdplayer-1.0-1/README</filename> is more than 3,600
          seconds, or one hour, old.  If we take a look at the file, we find
          that it is:
          <footnote>
            <para>
              It should be noted that the package was built
              <emphasis>substantially</emphasis> later than November of 1995!
            </para>
          </footnote>

          <screen width="60">
<prompt># </prompt><command>ls -al /usr/doc/cdplayer-1.0-1/README</command>
<computeroutput>
-rw-r--r--   1 root     root         1085 Nov 10  1995 README
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          In this particular case, the warning from
          <command>--timecheck</command> is no cause for alarm.  Since the
          <filename>README</filename> file was simply copied from the original
          source, which was created November 10th, 1995, its date is unchanged.
          If the file had been an executable or a library that was supposedly
          built recently, <command>--timecheck</command>'s warning should be
          taken more seriously.
        </para>
        <para>
          If you'd like to set a default time check value of one hour, you can
          include the following line in your <filename>rpmrc</filename> file:

          <screen width="60">
<computeroutput>
timecheck: 3600
</computeroutput>
          </screen>
        </para>
        <para>
          This value can still be overridden by a value on the command line, if
          desired.  For more information on the use of
          <filename>rpmrc</filename> files, see <xref linkend="ch-rpmrc-file">.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-vv-option">
        <title><command>-vv</command> &mdash; Display debugging
        information</title> <!-- label: build-vv -->
        <indexterm>
          <primary><command>-vv</command> option</primary>
        </indexterm>

        <para>
          Unlike most other RPM commands, there is no <command>-v</command>
          option for &rpmb;.  That's because the command's
          default is to be verbose.  However, even more information can be
          obtained by adding <command>-vv</command>.  Here's an example:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-bp -vv cdplayer-1.0.spec</command>
<computeroutput>
D: Switched to BASE package
D: Source(0) = sunsite.unc.edu:/pub/Linux/apps/sound/cds/cdplayer-1.0.tgz
D: Switching to part: 12
D: fileFile = 
D: Switched to package: (null)
D: Switching to part: 2
D: fileFile = 
D: Switching to part: 3
D: fileFile = 
D: Switching to part: 4
D: fileFile = 
D: Switching to part: 10
D: fileFile = 
D: Switched to package: (null)
* Package: cdplayer
D: RUNNING: %prep
+ umask 022
+ echo Executing: %prep
Executing: %prep
+ cd /usr/src/redhat/BUILD
+ cd /usr/src/redhat/BUILD
+ rm -rf cdplayer-1.0
+ gzip -dc /usr/src/redhat/SOURCES/cdplayer-1.0.tgz
+ tar -xvvf -
drwxrwxr-x root/users        0 Aug  4 22:30 1996 cdplayer-1.0/
-rw-r--r-- root/users    17982 Nov 10 01:10 1995 cdplayer-1.0/COPYING
&hellip;
-rw-r--r-- root/users     1515 Nov 10 01:10 1995 cdplayer-1.0/volume.h
+ [ 0 -ne 0 ]
+ cd cdplayer-1.0
+ cd /usr/src/redhat/BUILD/cdplayer-1.0
+ chown -R root.root .
+ chmod -R a+rX,g-w,o-w .
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          Most of the output generated by the <command>-vv</command> option is
          preceded by a <computeroutput>D:</computeroutput>.  In this example,
          the additional output represents RPM's internal processing during the
          start of the build process.  Using the <command>-vv</command> option
          with other build commands will produce different output.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-quiet-option">
        <title>
          <command>--quiet</command> &mdash; Produce as Little Output as
          Possible
        </title>
        <!-- label: build- -quiet -->
        <indexterm>
          <primary><command>--quiet</command> option</primary>
        </indexterm>

        <para>
          As we mentioned above, the build command is normally verbose.  The
          <command>--quiet</command> option can be used to cut down on the
          command's output:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>-ba --quiet cdplayer-1.0.spec</command>
<computeroutput>
* Package: cdplayer
volume.c: In function `mix_set_volume':
volume.c:67: warning: implicit declaration of function `ioctl'
90 blocks
82 blocks
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          This is the entire output from a package build of
          <filename>cdplayer</filename>.  Note that warning messages (actually,
          anything sent to stdout) are still printed.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-rcfile-option">
        <title>
          <command>--rcfile <replaceable>&lt;rcfile&gt;</replaceable></command>
          &mdash; Set alternate <filename>rpmrc</filename> file to
          <command><replaceable>&lt;rcfile&gt;</replaceable></command>
        </title>
        <!-- label: build- -rcfile -->
        <indexterm>
          <primary><command>--rcfile</command> option</primary>
        </indexterm>

        <para>
          The <command>--rcfile</command> option is used to specify a file
          containing default settings for RPM.  Normally, this option is not
          needed.  By default, RPM uses <filename>/etc/rpmrc</filename> and a
          file named <filename>.rpmrc</filename> located in your login
          directory.
        </para>
        <para>
          This option would be used if there was a need to switch between
          several sets of RPM defaults.  Software developers and package
          builders will normally be the only people using the
          <command>--rcfile</command> option.  For more information on
          <filename>rpmrc</filename> files, see <xref linkend="ch-rpmrc-file">.
        </para>
      </sect2>
    </sect1>

    <sect1 id="s1-rpm-b-command-other-build-commands">
      <title>Other Build-related Commands</title>
      <indexterm>
        <primary>&rpmb;</primary>
        <secondary>related commands</secondary>
      </indexterm>

      <para>
        There are two other commands that also perform build-related functions.
        However, they do not use the &rpmb; command syntax
        that we've been studying so far.  Instead of specifying the name of the
        spec file, as with &rpmb;, it's necessary to specify
        the name of the source package file.
      </para>
      <para>
        Why the difference in syntax?  The reason has to do with the differing
        functions of these commands.  Unlike &rpmb;, where
        the name of the game is to get software packaged into binary and source
        package files, these commands use an already-existing source package
        file as input.  Let's take a look at them:
      </para>

      <sect2 id="s2-rpm-b-command-recompile-option">
        <title>&rpmb; <command>--recompile</command> &mdash; What Does it
        Do?</title>
        <indexterm>
          <primary><command>--recompile</command> option</primary>
        </indexterm>

        <para>
          The <command>--recompile</command> option directs RPM to perform the
          following steps:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Install the specified source package file.
              </para>
            </listitem>

            <listitem>
              <para>
                Unpack the original sources.
              </para>
            </listitem>

            <listitem>
              <para>
                Build the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Install the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Remove the software's build directory structure.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          While you might think this sounds a great deal like an install of the
          source package file, followed by an &rpmb; <command>-bi</command>, this
          is not entirely the case.  Using <command>--recompile</command>, the
          only file required is the source package file.  After the software is
          built and installed, the only thing left, other than the newly
          installed software, is the original source package file.
        </para>
        <para>
          The <command>--recompile</command> option is normally used when a
          previously installed package needs to be recompiled.
          <command>--recompile</command> comes in handy when software needs to
          be compiled against a new version of the kernel.
        </para>
        <para>
          Here's what RPM displays during a <command>--recompile</command>:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>--recompile cdplayer-1.0-1.src.rpm</command>
<computeroutput>
Installing cdplayer-1.0-1.src.rpm
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Executing: sweep
&hellip;
+ exit 0
</computeroutput>
<prompt># </prompt>
          </screen>
        </para>
        <para>
          The very first line shows RPM installing the source package.  After
          that are ordinary executions of the <command>%prep</command>,
          <command>%build</command>, and <command>%install</command> sections of
          the spec file.  Finally, the cleanup of the software's build directory
          takes place, just as if the <command>--clean</command> option had been
          specified.
        </para>
        <para>
          Since &rpm; <command>-i</command> or &rpm; <command>-U</command> are not
          being used to install the software, the RPM database is not updated
          during a <command>--recompile</command>.  This means that doing a
          <command>--recompile</command> on an already-installed package may
          result in problems down the road, when RPM is used to upgrade or
          verify the package.
        </para>
      </sect2>

      <sect2 id="s2-rpm-b-command-rebuild-option">
        <title>&rpmb; <command>--rebuild</command> &mdash; What Does it Do?</title>
        <indexterm>
          <primary><command>--rebuild</command> option</primary>
        </indexterm>

        <para>
          Package builders, particularly those that create packages for multiple
          architectures, often need to build their packages starting from the
          original sources.  The <command>--rebuild</command> option does this,
          starting from a source package file.  Here is the list of steps it
          performs:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                Install the specified source package file.
              </para>
            </listitem>

            <listitem>
              <para>
                Unpack the original sources.
              </para>
            </listitem>

            <listitem>
              <para>
                Build the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Install the software.
              </para>
            </listitem>

            <listitem>
              <para>
                Create a binary package file.
              </para>
            </listitem>

            <listitem>
              <para>
                Remove the software's build directory tree.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Like the <command>--recompile</command> option,
          <command>--rebuild</command> cleans up after itself.  The only
          difference between the two commands is the fact that
          <command>--rebuild</command> also creates a binary package file.  The
          only remnants of a <command>--rebuild</command> are the original
          source package, the newly installed software, and a new binary package
          file.
        </para>
        <para>
          Package builders find this command especially handy, as it allows them
          to create new binary packages using one command, with no additional
          cleanups required.  There are several times when
          <command>--rebuild</command> is normally used:

          <itemizedlist mark="bullet">
            <listitem>
              <para>
                When the build environment (eg. compilers, libraries, etc.) has
                changed.
              </para>
            </listitem>

            <listitem>
              <para>
                When binary packages for a different architecture are to be
                built.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Here's an example of the <command>--rebuild</command> option in
          action:

          <screen width="60">
<prompt># </prompt>&rpmb; <command>--rebuild cdplayer-1.0-1.src.rpm</command>
<computeroutput>
Installing cdplayer-1.0-1.src.rpm
* Package: cdplayer
Executing: %prep
&hellip;
+ exit 0
Executing: %build
&hellip;
+ exit 0
Executing: %install
&hellip;
+ exit 0
Executing: special doc
&hellip;
+ exit 0
Binary Packaging: cdplayer-1.0-1
&hellip;
Executing: %clean
&hellip;
+ exit 0
Executing: sweep
&hellip;
+ exit 0
</computeroutput>
<prompt>#</prompt>
          </screen>
        </para>
        <para>
          The very first line shows RPM installing the source package.  The
          lines after that are ordinary executions of the
          <command>%prep</command>, <command>%build</command>, and
          <command>%install</command> sections of the spec file.  Next, a binary
          package file is created.  Finally, the spec file's
          <command>%clean</command> section (if one exists) is executed.  The
          cleanup of the software's build directory takes place, just as if the
          <command>--clean</command> option had been specified.
        </para>
        <para>
          That completes our overview of the commands used to build packages
          with RPM.  In the next chapter, we'll look at the various macros that
          are available and how they can make life easier for the package
          builder.
        </para>
      </sect2>
    </sect1>
  </chapter>
